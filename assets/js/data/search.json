[ { "title": "[AWS]OCI와 AWS의 차이", "url": "/posts/OCI%EC%99%80-AWS%EC%9D%98-%EC%B0%A8%EC%9D%B4/", "categories": "Tech, DevOps", "tags": "Tech, TIL, DevOps, AWS, OCI", "date": "2024-03-28 16:53:00 +0900", "snippet": "📌 아니이거왜같은이름달고서하는짓이달라요?회사에서는 주로 Oracle Cloud를 통해서 프로젝트를 진행하고 있었고, 회사에 쌓여있는 클라우드에 대한 지식도 오라클에 촛점이 맞춰져 있었다. 사실 클라우드 도입이 오래 된 것이 아니기 때문에, 팀 전체가 새로운 클라우드 프로바이더를 만날 때 마다 공부하는 방식으로 프로젝트를 진행하고 있었다. OCI는 안그러던데…?NCloud와 AWS를 쓰면서 상사에게 들었던 말이었다. 당시 상황을 보여주자면다음과 같이 한 로드밸런서에 두개의 인스턴스가 붙어있는 상태였다. 이 상황에서 만약 한 인스턴스의 WAS가 모종의 이유로 ( 오류나 배포)인해서 내려가게 되는데7레이어에 해당하는 보통의 ALB들은 Health Check를 하기 직전까지 이런 WAS의 이슈를 알지 못한다. 인스턴스 자체는 통신이 잘 되고 있기 때문, 그래서 이런 이슈가 존재하는 상태로 새로고침을 계속하면, 503과 정상페이지가 번갈아 나오는 것을 확인할 수 있다.위와 같이 Health Check전까지는 계속해서 이슈 페이지가 뜬다. 이건 네이버 클라우드도 이런식이고, 그래서 배포 할때에도 문제가 존재했다.정말 신기하게도, OCI는 이렇지 않다. OCI는 어느정도 failover도 겸하는 리버스 프록시의 역할도 로드밸런서가 겸한다.그래서 위의 이미지와 같이 다른 타겟인스턴스로 보내버린다. 그래서 약간의 딜레이가 존재하긴 하지만 정상적인 페이지만 계속해서 보내주게 된다. Nginx와 같은 WAS 레벨의 로드밸런서, 리버스 프록시의 역할도 겸하면서 작동하게 되는 것이다.AWS도 Ncloud도 이런식으로 동작 하지 않아서, 조금 혼란이 있었다.🤦 배포상의 이슈그래서 우리팀이 기존에 사용하던 오라클 클라우드와 다른 ALB의 작동 방식으로 인해서, 배포를 진행 할 경우 배포를 받은 인스턴스에서 503 에러가 그대로 클라이언트 단으로 타고 흘러 나가는 문제가 발생했다. 네이버 클라우드에서 진행중인 프로젝트의 코드를 배포하면 일시적으로 503과 정상페이지가 번갈아 뜨는 것이었다.일단 OCI의 의외의 놀라움은 제쳐두고 GO 언어를 통해서 배포시에 ALB Target Group에서 인스턴스를 일시적으로 등록 해제하도록 하는 유틸리티와, 해제했던 인스턴스를 등록하는 유틸리티를 GO언어를 통해서 작성했다.(생각보다 NCloud의 CLI나, GO SDK에 대한 사용성이 API 자체와 너무나도 달랐다…)이런저런 이슈들을 뒤로하고 일단 급하게나마 회사 배포 환경에 맞는 유틸리티 작성한다고 좀 고생했다. 바이너리 파일 형태로 리눅스에서 돌릴 수 있도록 하기 위해서 가장 최적화 된 언어가 GO였고, 새로운 언어 적응한다고 챗GPT와 함께 열심히 굴러다녔다.ALB가 다 같은 ALB가 아니다 - 오늘의 교훈" }, { "title": "[AWS]AWS SAA 공부 - EC2", "url": "/posts/AWS-%EA%B3%B5%EB%B6%80-1/", "categories": "Tech, DevOps", "tags": "Tech, TIL, DevOps, AWS, Github", "date": "2023-07-19 23:37:00 +0900", "snippet": "📌 AWS SAA 자격증을 위한 중간 정리 - EC2📎 AWS EC2에 대해서…Amazon Elastic Compute Cloud (이하 EC2)는 프로세스부터 OS까지 사용자가 직접 취사선택하여 생성할 수 있는 클라우드 인스턴스이다. 이후에 나오는 AWS의 다양한 서비스의 근간이 되는 서비스 이며, 서비스의 형태에 맞춰 특화된 다른 서비스와는 다르게 EC2는 어떤 서비스에도 대응할 수 있는, 기본중의 기본이다.EC2의 인스턴스 유형EC2는 다양한 형식의 인스턴스를 지원하며 인스턴스의 첫 알파벳에서 어떤 인스턴스인지 알 수 있다. 범용적인, 균형있는 컴퓨팅을 위한 M, T 고성능 프로세서를 사용하는 C 대규모 데이터 세트를 처리하기 위한 메모리가 최적화 된 R, X - 엘라스틱 캐시 스토리지에 최적화 되어있는, OLTP 시스템에 사용하는 I, G, H1 - RDB, NoSQLEC2의 사용 플랜EC2는 사용의 용도에 맞춰서 다양한 요금 플랜을 지원한다. 사용한 만큼 내는 온디맨드 장기간 계약을 통해서 금액을 할인받는 Savings Plans 선결제 예약을 통해서 금액을 할인받는 Reserved Instances 그리고 경매와 유사한 시스템인 Spot Instances EC2의 하드웨어를 완전히 dedicate 받을 수 있는 Dedicated HostsElastic IP 탄력적 IP탄력적 IP는 인스턴스를 인터넷에 노출시킬 수 있는 공용 IP계정당 5개 생성 가능 결론적으로는 Elastic IP를 직접 인스턴스에 할당하지 말자, 제어도 힘들고 확장도 어렵다 Placement Groups 배치 그룹각각의 EC2들이 서로 어떤식으로 배치 될 것인가에 관해서 정의하는 방식이다. 각 그룹에 해당하는 EC2 인스턴스들은 해당하는 그룹 셋팅에 맞게 배치되게 된다. Cluster 클러스터 클러스터 배치 방식은 Latency가 가장 적은 방식으로 단일 AZ에 EC2들이 배치된다. 가장 빠르지만 가장 위험한 배치 방식처리 사용예시) 빅데이터 처리 Spread 분산 spread는 하드웨어에 분산하여 배치하는 것으로 AZ 당 7개의 인스턴스만 가능하다는 제약 사항이 있다. 장애에 있어서 가장 안전한 방식이다. 사용예시) 장애에 민감한 크리티컬한 어플리케이션 Partition 분할 파티션을 기준으로 인스턴스를 나눈다. 파티션은 동일한 랙을 기준으로 하는데, 각 파티션 끼리는 실패로 부터 격리되어 안전하고, 파티션 내부에서는 충분한 속도 확보가 되는 효율적인 방식이다. 사용예시) 카산드라, 카프카 ENI Elastic Network InterfacesENI는 Elastic IP와 동일하게 EC2가 네트워크에 연결할 수 있도록 해주는 가상 네트워크 카드다.ENI 는 private IPv4와 public IPv4를 가질 수 있으며, private IPv4 하나당 Elastic IP 하나와, 여러개의 보안그룹, 그리고 MAC 어드레스를 attribute로 가질 수 있다.ENI를 교체해서 배포나 업데이트가 가능하고 (다만 Elstic IP를 통해서 처리하는게 가능하다)또는 MAC Address에 라이센스가 종속된 경우, ENI에 라이센스를 부여하고 EC2 인스턴스를 바꿔가면서 서비스가 가능하다.Elastic IP VS ENI두 개의 서비스 모두 IP 네트워크와 관련 되어 있고, Elastic 이라는 명칭이 붙어서 헷갈릴 수 있다.다음과 같은 차이점을 보인다.Elastic IPElastic IP는, 테이블로 관리되는 public IP에 대하여 고정해주는 서비스이다. 테이블에 다양한 public IP가 존재하며, EC2가 생성되면서 같이 생성되는 ENI의 private IP를 특정 public IP주소와 고정적으로 연결해주는 서비스로, 통상적으로 EC2가 재부팅 되면 새로운 publc IP에 할당되어야 할 IP를 고정적으로 할당해주는 서비스를 뜻한다.ENIENI는 위와 동일하게 가상의 네트워크 카드로, EC2하나에 여러개의 ENI를 둘 수 있으며, 실질적으로 subnet에 존재하는건 EC2가 아닌 ENI로, EC2에 다양한 ENI를 설치하고, 각 ENI를 public과 private subnet에 각각 위치 시키고, 다른 보안 그룹을 설정하여서 EC2에 다양한 방식으로 접근할 수 있도록 설정 할 수 있다.EC2 Hibernate 절전EC2를 완전하게 종료하는 Terminate와는 다르게 EC2를 일시적을 절전모드에 넣는 것으로, 메모리에 존재하는 정보를 EBS 볼륨에 저장하고(이 때, EBS는 암호화 되어야 함) EC2를 종료하고, 다시 켜면 EBS에 있는 정보를 그대로 메모리로 호출하게 된다. 메모리의 크기가 150기가 이하여야 하며, EBS에 메모리의 정보를 저장할 충분한 공간이 있어야 한다." }, { "title": "[Kotlin] 코틀린은 빌더 패턴을 필요로 할까?", "url": "/posts/does-kotlin-need-builder-pattern/", "categories": "ProgrammingLanguage, Kotlin", "tags": "Kotlin, ProgrammingLanguage, JVM", "date": "2023-03-28 13:50:20 +0900", "snippet": "엥 빌더 패턴?디자인 패턴을 공부해 봤다면, 빌더패턴에 대해서 알고 있을 것이다. 그래도 홍옥 시나 알쏭달쏭할만한 분들을 위해서 간략하게 설명을 하자면..클래스 { 빌더 { 클래스 리턴하는 메서드 build() }}다음과 같은 구조로 클래스 내부의 클래스 프로퍼티들을 받아 클래스를 리턴하는 빌더를 생성하여서, 그 빌더를 통해서 클래스를 생성하는 방법이다.클래스 내부에 필수적인 프로퍼티와 Nullable한 프로퍼티들을 구분하여 사용할 수 있으며, 만약 새로운 Nullable한 프로퍼티가 생기더라도, 중간의 빌더 패턴을 한번 통해주면, 디폴트 값을 넣어주면서 모든 코드를 수정하지 않아도 되는 장점이 있다.public class Student { private final String name; private final int studentNumber; private final String hobby; private final String address; pubic Student(String name, Int studentNumber) { return this(name, studentNumber, null, null); } public Student(String name, Int studentNumber, String hobby) { return this(name, studentNumber, hobby, null); } public Student(String name, Int studentNumber, String hobby, String address) { return this(name, studentNumber, hobby, address); }}단순하게 생각한다면, 자바는 오버로딩을 통해서, 다양한 생성자 입력에 대해서 각각의 생성자메소드를 통해 생성해줘야 할것이다.Effective Style Builder Patternpublic class Student { private final String name; private final int studentNumber; private final String hobby; private final String address; private Student(Builder builder) { this.name = builder.name; this.studentNumber = builder.studentNumber; this.hobby = builder.hobby; this.address = builder.address; } public static class Builder { private final String name; private final int studentNumber; private String hobby = null; private String address = null; public Builder(String name, int studentNumber) { this.name = name; this.studentNumber = studentNumber; } public Builder hobby(String hobby) { this.hobby = hobby; return this; } public Builder address(String address) { this.address = address; return this; } public Student build() { return new Student(this); } }}...Student.Builder builder = new Student.Builder(\"InGyu\", 2023, \"guiter\", \"Incheon\");Student student = builder.build();orStudent student = new Student.Builder(\"InGyu\", 2023) .hobby(\"guitar\") .address(\"Incheon\") .build();..빌더패턴은 다음과 같이 내부 스태틱클래스를 통해서, 입력된 값에 따라 Builder인스턴스를 생성하여 Builder인스턴스가 클래스를 생성해 리턴해주는 디자인 패턴이다. 객체를 한번에 생성하며, 함수의 입력값이 맞는지, 필수적인 변수와 아닌 변수도 나눌 수 있게 된다.🤦 To Kotlin.그렇다면 코틀린은 어떨까? 먼저 코틀린으로 단순하게 마이그레이션 해보자class Student private constructor(builder: Builder) { private val name: String private val studentNumber: Int private val hobby: String? private val address: String? init { name = builder.name studentNumber = builder.studentNumber hobby = builder.hobby address = builder.address } class Builder( val name: String, val studentNumber: Int, hobby: String?, address: String?) { var hobby: String? = null var address: String? = null fun hobby(hobby: String?): Builder { this.hobby = hobby return this } fun address(address: String?): Builder { this.address = address return this } fun build(): Student { return Student(this) } }}intelliJ에 그대로 복붙해서, 약간의 오류를 고쳐주고 나면 다음과 같은 코드가 자동으로 생성된다. Student의 생성자 파라미터로 Builder를 넣어주고, 이 Student는 Builder의 값들을 받아서 초기화 된다. Student의 내부 클래스 Builder는 파라미터들을 받아서 각각의 값들로 넣어주고, build()를 통해서 Student를 리턴하게 된다.사실 Builder클래스는 결국 데이터를 핸들링 하는 것에 의미가 있기 때문에, 코틀린 Data Class를 사용해서 다음과 같이도 리팩토링이 가능하다.class Student private constructor( val name: String, val studentNumber: Int, val hobby: String?, val address: String?) { data class Builder( val name: String, val studentNumber: Int, var hobby: String? = null, var address: String? = null ) { fun address(address: String) = apply { this.address = address } fun hobby(hobby: String) = apply { this.address = address } fun build() = Student(name, studentNumber, hobby, address) }}코틀린 스타일이 가미된, 방식의 코드다. Builder가 Data Class로 존재하며, 파라미터들을 받아 초기화 되고, build()는 Student를 리턴한다.데이터 클래스를 통해서 마치 Class의 DTO처럼 데이터를 그대로 가져와 클래스를 생성해주는 이런 방식으로 빌더 패턴을 만들 수 있다.📎 conclusion위의 예시만 봐도 알겠지만, 자바보다는 훨씬 더 간결한 코드로 보여줄 수 있으며, 그런 간결해진 문장을 통해서 자바의 코드보다 훨씬 더 이해가 쉽고 명확하다는 것을 알 수 있다. 또한, 코틀린의 라이브러리 함수들, apply와 같은 예시에 DSL에 대한 이해도 까지 더해진다면 정말 간결하고 명확한 코드들을 직접 짤 수 있게 된다.val student = Student.Builder(\"InGyu\", 2023) .address(\"Incheon\") .hobby(\"guitar\") .build()" }, { "title": "[Dart]Dart에서 Getter와 Setter", "url": "/posts/dart-getter-setter/", "categories": "Tech, Infrastructure", "tags": "TIL, Tech, Dart, Flutter", "date": "2023-03-08 10:20:00 +0900", "snippet": "📌 Dart에서 Getter와 Setter여느때와 같이 Peach-Tri에서 스터디를 진행중이었다. 진행 도중에 riverpod 예시코드들에 getter setter 세팅이 전혀 없다는 점을 팀원이 이상하게 느꼈고, 그걸 기점으로 Dart라는 언어의 지향점이 어딘지에 대해서 의문을 품게 되었다. 너무나도 당연하게 Java스타일로 Getter Setter를 정해놓던 우리는 코드 작성 시간보다 디자인 패턴 파악에 긴 시간을 쏟은 결과, Dart의 도큐먼트와 몇몇 글들을 알게 되었고, 시작은 Dart지만 아마 이 내용은 전반적인 프로그래밍 언어의 흐름에 대해서 일 수도 있을 것 같다.📎 Getter? Setter?☕ In JavaJava에서 Getter와 Setter는 필수적이다. Lombok이라는 라이브러리를 활용해서라도, 이 불편한 accessor를 사용하게 한다. 이는 OOP의 원칙 중 하나인 캡슐화를 이뤄내기 위함이며, CLASS 내부적으로 private로 선언한 field들에 대해서 접근을 컨트롤 할 수 있는 하나의 입출구로 생각하면 이해할 수 있다. 학부생정도에서, 그리고 깊지 않은 프로그래밍 공부에서는 DTO나 Entity의 역할을 하는 클래스들이 줄줄이 getter와 setter를, 그저 단순접근을 제어하기 위해라는 목적하에 줄줄이 달려있는 것을 알 수 있다. 다만 이런 접근자들이 진짜로 필요한지에 대해서 재고해야한다.과연 그저 모든 field들에 getter와 setter를 붙이는 것 만으로 캡슐화라는 목표를 이룩할 수 있는 것일까?🎯 In Dart다트는 이런 단순접근자들을 사용하는것을 지양하라고 나와있다. AVOID wrapping fields in getters and setters just to be “safe”.단순한 안전을 위해서, getter와 setter를 통해서 필드들을 매핑하는것은 의미가 없다는 말이다🤦 근데 이제와서 왜 우리는 사용하지 않는걸까?class Example { private String name; private int age; public void setName (String name) { this.name = name; } public String getName (String name) { return this.name; } public void set age (int age) { this.age = age; } public int getAge (int age) { return age; }}다음과 같은 자바 코드가 있다고 가정할 때, 과연 캡슐화되어 있는지 생각해보자, 클래스의 내부 field들은 private 상태이다. 하지만 정작 모든 field들이 public getter와 setter로 인해서 노출되어 있는 상태이다. 외부에서 이 class를 활용하려고 한다면, 내부적으로 어떤 구조를 하고 있는지, 어떤 형태를 띄고 있는지 알아야 하고, 이런 구조는 getter setter없이 그냥 .을 사용하는 것과 별반 다를 바 없는 구조를 갖게 되는 것이다. 이것은 언뜻 느끼기에는 캡슐화를 달성한 것 같아 보인다. 하지만 궁극적으로 추상화를 목표로 하는 OOP에서는 오히려 추상화를 해치고 내부 구조를 드러낸 것과 다를바 없는 코드가 되어 버린다. 단순 데이터 전달 목적이 아닌, 나름의 역할과 책임을 가진 클래스가 이러한 상태라면 캡슐화가 정상적으로 작동한다고 보기 어렵다....public boolean isSame(Example example) { return (example.age == someAge) ? true : false;}...접근제어자들은 API 즉 인터페이스들이고 인터페이스는 내부로직을 숨기고 객체에게 역할을 부여하며, 외부에서 다른 클래스들이 내부 값을 가져가 비교하거나 변환하는것이 아닌, 해당객체에게 값을 주면서 질문을 해야한다는 것이 핵심이다. 아래의 메소드는 Example내부에 존재하며, private한 값을 반환하지 않고도, 값을 비교할 수 있게 된다.class Example { ... public boolean isSame (int age) { return (age == this.age) ? true : false; } public boolean isSame (Stirng name) { return (name == this.name) ? true : false; } ...}위의 예시들은 극도로 단순하여 차라리 getter setter없이 field를 바로 가져오는게 더 실용적이겠지만, 더 복잡하고, 혹은 더 다양한 순간들에서 단순한 값 전달을 좀 더 확실하게하기 위해서 getter와 setter를 사용하는 것은 오히려 캡슐화를 하고 있다는 착각에 사로잡힐 수 있는 것이다.캡슐화는 정보은닉, 그리고 더 나아가서 OOP의 궁극적 목표인 추상화에 도달하기 위해, 그리고 각 클래스에 역할과 책임을 부여하기 위해서 각 객체들이 서로 커뮤니케이션을 위해서 구조를 알아야 하는 것이 아니라, 각 객체들이 서로에게 질문을 던지고 답변을 들으며 커뮤니케이션을 한다고 생각하면 편하다.💁 그렇다면 적절한 Accessor의 사용은 어떤 때 일까?Accessor들을 활용하기 가장 적합한 위치는 바로 추가적인 연산이나 데이터에 변동이 필요한 때이다. getter나 setter를 통해서 값이 바로 들어가는 것이 아니라, 그 중간에 값을 빼온다는지, 데이터에 따라서 따로 가공이 필요한 케이스의 경우에는 이런 getter setter를 통해서 중간다리 역할을 해줄 수 있다. 이런경우는 의심치 않고 getter setter를 활용하는 것이 도움이 될 것이다. 혹은 입력값에 따라서 Data내부에 있는 Type으로 변환하는 경우도 있을 수 있다. Data가 품고 있는 값을 String으로 입력된 이름으로 가져오고 싶다던지하는 경우는 getter setter를 활용할 여지가 충분히 존재한다. 직접적으로 자료형 그대로 가져오려고 하지 말고, 그 데이터를 통해 무엇을 하고 싶은지를 분리해내자사실 위와 같은 부분에서도 getter를 사용하기 애매한 부분이 분명히 존재한다. 정말 단순히 (ex: 전화번호 파싱이라던지) 하는 부분이 아니라면, 어떤 일을 할지에 더 중점을 두고 처리하는 것이 바람직 하다.DONTclass 서비스 객체 { fun addThisToExampleListClass(example: Example) { exampleListClassInstance.getNames.add(example.name) exampleListClassInstance.getAges.add(example.age) }}DOclass 서비스 객체 { fun addThisToExampleListClass(example: Example) { exampleListClassInstance.addExample(example) }}class ExampleListClass { fun addExample(example: Example) { this.exampleList.put(example) } }위의 예시가 완성도 높지는 않지만, 예시처럼, 서비스 객체에서 직접 다른 객체를 가져와 내부에 getter setter를 통해서 버무리는 것이 아니라, 객체에 있는 public함수를 통해 어떤 동작을 하도록 메시지를 보내고, 해당하는 객체는 요청에 맞는 행동을 하도록 하는 것이 더 바람직한 캡슐화가 된다.📖 참고자료 https://erik-engheim.medium.com/to-hell-with-setters-and-getters-7814e7b2f949 https://dart-lang.github.io/linter/lints/unnecessary_getters_setters.html https://stackoverflow.com/questions/61720221/why-should-i-avoid-wrapping-fields-in-getters-and-setters https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors " }, { "title": "[Server]분산 모놀리식 VS MSA", "url": "/posts/dist-mono-vs-msa/", "categories": "Tech, Infrastructure", "tags": "Tech, Infrastructure, Server, Backend", "date": "2023-03-08 10:20:00 +0900", "snippet": "📌 분산 모놀리식 VS MSA가장 최근의 인프라스트럭처에서 가장 핫한 이슈라고 한다면 단연코 Micro Service라고 말할 수 있다.Micro Service Architecture(이하 MSA)는 커다란 하나의 Monolithic구성이었던 서버 시스템을 각각의 서비스 단위로 찢어두면서, 분리된 서비스들을 각자 유지보수하거나, Scale-Out하는 방식으로 Scalability를 끌어올려주는 방식이다. 시스템이 단일로 존재하는 것이 아니다보&gt;니, 배포할 때에도 각 서비스 단위로 배포가 가능하며, 리소스들을 각자 가지고 있기 때문에 장애에 대응하기에도 좀 더 적절한 방식이라고 볼 수 있다.📎 분산 모놀리식은 무엇일까?분산 모놀리식(Distributed Monolithic)방식은 MSA와 Monolithic의 중간 방식이라고 할 수 있다. 서비스들이 자원을 공유 한다던지, 코드베이스를 공유한다던지, 서비스들간의 통신이 잦지 않은 방식이라던지, 배포시 한번에 전부 배포하는 방식등의 완전히 분리되지 않고 연결되어있다면 분산 모놀리식이라고 할 수 있다. MSA를 위해서는 전체적인 아키텍쳐 변화 뿐만이 아니라, DBA, 복잡한 커뮤니케이션 망을 이해하고 리드할 수 있는 테크리드와 전반적인 팀 구조적으로도 MSA와 같이 따라줘야 완성할 수 있다. MSA는 실질적으로는 매우 비용이 많이 드는 아키텍쳐라고 할 수 있다. 따라서 규모가 매우 거대한 기업이나 전문가가 많은, 인적자원이 풍부한 기업이 아니면 꺼리게 되는 점도 사실이다.🤦 분산 모놀리식의 문제점분산 모놀리식은 MSA와 모놀리식의 장점과 단점을 전부 아우르는 방식의 아키텍쳐이다.📌 장점 모놀리식처럼 전체적인 서비스의 흐름을 파악하기 유용하다 차후의 MSA로 넘어가기에 좋다 위의 존재하는 분산 모놀리식 체크리스트에서 MSA에 가까운 특징들이 존재한다면 모놀리식보다 유지보수에서 편리함을 가져갈 수 있다📌 단점 Scalability에 있어서 문제가 존재한다 서비스간의 종속성이 존재한다 결국은 전체적으로 Monolithic의 단점을 가지게 된다 애매한 방식으로 나눠놨을 경우, 분산하기도 힘들고 유지보수도 힘든 계륵일 수 있다차후의 MSA로 넘어가기 위한, 혹은 Monolithic의 배포방식보다는 서비스간의 분산된 배포를 위해서, 등등의 의도된 경우가 아니고, 완전한 MSA로 넘어가기 위해서는 몇가지 꼭 체크해야하는 리스트가 존재한다. 다음과 같은 리스트를 확인해보면, 의도적으로 MSA로 디자인된 시스템이 과연 정말로 MSA인지에 관래서 고찰할 필요가 있다.📌 서비스들이 데이터를 분리하여 가지고 있는가?다음과 같이 데이터베이스를 공유하고 있다면 그것은 분산 모놀리식을 의심해봐야한다. MSA는 각 서비스가 각자의 DB가 존재하고 그렇기 때문에 서비스 간의 커뮤니케이션이 요구된다.📌 코드베이스와 라이브러리의 공유 -&gt; 서비스간의 의존성MSA의 서비스들은 각각의 라이브러리가 존재하면서, 코드베이스를 공유하지 않아서 서로에 대해서 종속성을 가지고 있지 않다. 하지만 분산 모놀리식의 경우 이런 부분에서 의존성을 남겨놓는 경우가 많다.따라서, 일부의 수정 -&gt; 전체의 변화로 이어지는 경우가 발생한다.📌 동기적인 통신MSA의 핵심은 서비스들간의 통신이다. 전체 서비스가 전부 찢어져 있기 때문에 서비스들이 서로 계속해서 소통하면서 Flow가 흘러간다. 만약 서비스들간의 통신방식이 동기적이라면, 한 서비스가 다른서비스를 기다리는 정체가 일어나게 된다. 이러한 방식은 MSA의 취지에 부합하지 않으며, 크게 봤을때 하나의 시스템으로 돌아가는 Monolithic과 크게 다르지 않다고 볼 수 있다.📌 Event Sourcing을 사용하지 않는 시스템Event Sourcing은 현재, 최신의 상태만 저장하는 방식이 아니라, 발생한 모든 이벤트에 대해서 저장하는 방식이다. MSA의 경우 비동기적 통신을 사용하기 때문에 이러한 이벤트를 기반으로 통신하는 경우가 존재한다. Event들은 수정될 수 없고, 재생성하기 쉬우며, 시스템 전반에 걸쳐서 존재하기 때문에 MSA는 이 소싱된 이벤트들을 하나의 Log처럼 이용한다. 이런 이벤트들은 DB와는 또 다른 개념으로 동작한다. 시스템 전반에 걸쳐서 메시징처럼 동작하기 때문에 서비스들이 서로에 대해서 신경쓸 필요 없이 자신에게 존재하는 이벤트를 쭉 처리하면 되는 것이다.분산 모놀리식은 반대로, 이러한 이벤트를 필요로 하지 않는다. 분리되어 있지 않은(혹은 분리되어 있으나 느슨하게 결합된) 형태의 DB는 굳이 이벤트를 전반에 제공할 필요 없이 DB와 다이렉트로 소통하는 것이 훨씬 유용하기 때문에 Event Sourcing을 필요로 하지 않는다📖 참고자료 https://scoutapm.com/blog/distributed-monoliths-vs-microservices https://sarc.io/index.php/cloud/2091-event-sourcing https://ssup2.github.io/theory_analysis/Event_Sourcing_Pattern/ " }, { "title": "[Blog]2022년 회고록", "url": "/posts/2022remind/", "categories": "Blogging, Remind", "tags": "Blog, Life", "date": "2022-12-30 16:48:00 +0900", "snippet": "📌 경험의 한해 2022년나에게 2022년이 어떤 해였냐고 한다면, 경험의 한해였다고 생각한다. 2022년은 마지막 학년의 시작이었으며, 사회로의 도약을 시작하는 해였고, 같이 일했던 누군가와의 마지막날이며, 새로운 인연을 쌓아가는 일년이었다. 나의 인생에 있어서 첫번째 4학년이며, 첫번째 인턴십, 첫번째의 구인구직 면접을 보는 그런 해였다.📎 4학년은 누구보다 몸이 여유롭고, 누구보다 바쁜 한 해였다고 생각한다.나에게 있어서 이번 4학년은 여유로웠다. 내가 실질적으로 학점을 채워야 하는 학기는 한 학기였으며, 4학년 1학기는 클라우드 컴퓨팅에 눈을 뜨는 학기였다. 오히려 내가 흥미롭게 생각했던 인공지능이 좀 더 수학적이고, 학문에 가까워서 식었던 반면, 클라우드 컴퓨팅의 여러 기술적인 트러블 슈팅과 한계를 어떤 방식으로 극복했는지에 대한 (교수님의 명강의) 내용들은 내가 다루고 싶어하던 서버, 백엔드, 네트워크에 좀 더 크게 흥미를 느끼게 만들었다. 다양한 기술적 흐름들이 우리를 흥미롭게 했으며, 기존에 존재했던 방식들이 쌓이고 쌓여서 또 새로운 해결법을 찾아나가는 흐름이 매우 흥미로웠다. 나에게 클라우드, AWS와 같은 다양한 서비스, 도커, 쿠버네티스와 관련해서, 그리고 DevOps라는 분야에 눈을 뜨게 만들고, 코딩과 다른 엔지니어에 눈을 뜨게 만들었던 한 해라고 생각한다.📎 4학년 2학기, 인턴십의 시작 - 큐링이노스2학기에 접어들어서 나는 매우 인턴십을 생각하고 있었다. 나는 필드에서 더 적극적으로 배우고 수용하려는 사람이다. 강의 한번보다 실습한번에 더 많은걸 흡수하고, 책 한권 보다 프로젝트 한번이 더 많이 흡수하는 느낌이다. 물론 모든사람이 그렇겠지만.다행히 기회가 닿아서 송도 스타트업 큐링이노스에서 인턴십을 진행할 기회가 생겼고, 나는 이 기회를 놓치지 않고 잡았다. 처음으로 회사에서 모르는 사람들과 면접을 보고, 모르는 사람들에게 나라는 사람을 PR하면서 동시에 나는 처음보는 회사가 어떤 회사인지 물어보는 대화가 이어졌다. 내가 블로그에도 작성해놓고 대답하지 못하는 질문도 있었고, 내가 안다고 자부했던 내용도 결국 그 자리에서는 알듯말듯한 내용도 있었다. 면접중에 크게 느꼈던 점은 프로젝트를 진행했다는 점이 참 이야기 할 거리가 많아 진다는 점이다. 나의 부족한 능력, 포트폴리오에도 큐링이노스에서 다행히 인연이 닿았고, 알차게 큐링이노스에서 일하게 되었다. 나의 직책은 백엔드 개발자였으며, 회사내 프로젝트에 요구되는 서버를 개발하고, AWS를 통해서 인프라를 구축했다.🤷‍♂️ 면접면접면접모호한 면접자는 고통 받는다. 면접관은 이 면접자에 대해서 잡히는게 없기 때문에 더 많은 질문을 하게 되고, 면접자는 자신에 대해서 모호하게 PR했기 때문에 모호한 것을 구체화 시키기 위해서 머리를 싸매야 한다. 큐링이노스 면접에서 이 점을 많이 느꼈다. 내가 블로그에 적었던 내용들이 존재하기 때문에, 면접관들은 이 내용을 내가 알고있다라고 생각 할 수 있고, 나도 이 내용들을 구체화 시켰기 때문에 자연스럽게 제안할 수 있다. 블로그에 작성한 프로젝트 내용 덕분에 면접관들은 구체적으로 물어보고 싶은 내용들이 생기며, 나는 이 내용들에 대해서 이미 생각한 점 이기 때문에 대답할 수 있다(그것이 호기심에 불과하더라도, ‘써보고 싶었다’라고 이야기 할 수 있는 것이다. 호기심에도 ‘왜’는 존재한다.) 큐링이노스는 물론이고, 현재 근무하고 있는 파이언넷에서의 면접에서도 이런점이 여실히 느껴졌다.🤦 새로운 언어, 새로운 분야큐링이노스에서 사용한 언어는 Kotlin + Spring이다. 처음에는 Kotlin이라는 언어가 굉장히 생소했다. var과 val도 헷갈리며, Spring에서 기본적으로 사용하는 내용들이 너무 많이 함축적으로 줄어들었고, 코틀린을 위해서 추가적으로 플러그인을 사용하고 적용해줘야하는 내용들이 존재했다. 하지만 결국 인간은 적응의 동물이라고 이제는 자바랑 서먹서먹한 사이가 되었다. 둘이 내부적으로 크게 다르지 않으면서 다른 언어이고, 적응이 잘 되면서 동시에 유사해서 헷갈리기도 한다. Kotlin이라는 언어는 새로웠고 어려웠지만, 그 만큼 또 흥미롭고 효율적인 언어라고 생각된다. 또한 AWS는 어려웠다. 코딩과는 또 다른게 인프라 구축이다. 머릿속에 큰 그림이 존재해야하고, 한두가지 요소만 없어도 못해먹겠다면서 빌드스크립트는 오류를 뱉어내고 로그에는 빨간불이 뜬다. 나는 오히려 이 점이 재미있었다. 보이지 않는 파이프라인을 직접 빌드하고 구축하는 기분이다. 이런 파이프라인 구축과 같은 큰 그림을 과연 스타트업이 아니라면 어디서 경험했을까 싶다. 내가 경험하는 모든 것들이 새롭고 생소했으며, 넓은 범위에서 나를 다양한 방향으로 이끌었고, 이런소중하고 고마운 경험들을 좋은 사람들과 큐링이노스에서 나눴다.👨‍🎓 졸업, 그리고..나는 이제 졸업을 앞두고 있고, 인턴십이 끝난 현재, 파이언넷이라는 E-커머스 솔루션 SI회사에 들어가게 되었다. 해당 회사에 면접을 볼 때 말했던 대로, 나는 전문성을 띈 개발자를 희망하고 있다. 한 분야에 큰 전문성을 가지고 있는 개발자, 그러면서도 큰 그림을 그릴 수 있는 개발자. 서비스에 필요한 흐름에, 그림에 인프라부터 프로덕션 코드까지 어떤 그림을 그려야 할지 꿰뚫고 있는 개발자가 되려고 한다. 공부도 정말 많이 해야하고, 그러면서 또 적응해나가야 하겠지만…" }, { "title": "[DevOps]아마존 AWS를 통한 CI/CD 구축 -2 (with CodeDeploy)", "url": "/posts/CI-CD-with-aws-codedeploy/", "categories": "Tech, DevOps", "tags": "Tech, TIL, DevOps, AWS, Github", "date": "2022-09-21 17:51:35 +0900", "snippet": "오픈 소스들을 통한 (ex - 젠킨스) CI/CD는 커스텀 가능한 파이프라인을 통한 장점과 각각의 CI/CD툴을 선택해서 사용할 수 있다는 장점이 있다. 그렇다면, 최대의 서버리스 서비스를 지원하는 AWS는 과연 어떤 식으로 파이프라인을 구축할 수 있을까?📎 AWS의 CodePipelineaws는 CodePipeline이라는 서비스를 통해서 이용자에게 CI/CD 파이프라인을 매니지먼트 할 수 있도록 한다. 각 파이프 라인에서, 어떤 빌드, 어떤 배포를 선택할지 정할 수 있으며, 유동적으로 변경과 재실행이 가능하게 관리 가능하다는 점이 정말로 편리하다.전체 파이프라인의 진행 상태도 확인할 수 있으며, 각각 세부적인 파트의 상태또한 확인할 수 있어서 직관적이다.CodePipeline에서는 코드를 가져올 소스, 코드를 어떤 방식으로 빌드 할지, 코드를 어떤 방식으로 Deploy할지에 관해서 한눈에 파악이 가능하고, 그 정보들을 바탕으로 파이프라인의 흐름이 잘 유지되고 있는지 확인할 수 있다.🏗 AWS CodeBuildAWS의 CodeBuild서비스는 말 그대로 코드를 빌드하는 서비스다(이름부터 직관적이다.) 코드를 어떤 환경에서, jar파일을 어떤 방식으로, 어떤 환경변수를 넣어서 사용할지에 대해서 구체적으로 정해줄 수 있다. 만약 application.yml파일을 사용한다면, 어떤 프로파일을, EC2내부에 저장했다면 어떤 위치에 있는 파일을 활용할지에 대해서도 정해줄 수 있다.version: 0.2phases: install: runtime-versions: java: corretto17 build: commands: - echo Build Starting on `date` - gradle wrap - chmod +x ./gradlew - ./gradlew build post_build: commands: - echo $(basename ./build/libs/*.jar) - pwdartifacts: files: - appspec.yml - build/libs/*.jar - scripts/** discard-paths: yescache: paths: - \"/root/.gradle/caches/**/*\" buildspec.yml다음과 같이 yaml파일을 작성해서 런타임 버전이라던지, 명령어라던지, 빌드가 끝나고 마무리를 정할 수 있다.🤦 Trouble ShootingAWS 연결 권한 이슈 [해결]github와 AWS간의 커뮤니케이션 딜레이S3 권한 설정 이슈 [해결]Github에서 AWS S3버킷으로 보내거나 CodeDeploy를 사용하기 위한 권한, Key가 존재하지 않아서 생김.AWS를 사용함에 있어서 중요한 것은 IAM을 통한 권한 설정입니다. Deploy를 위한 권한, S3 버킷을 이용하기 위한 권한 등등이 Deploy에 필요로 하기 때문에 이러한 권한이 적절히 부여되어 있는지 확인해야 합니다.https://goodgid.github.io/Github-Action-CI-CD-AWS-S3/S3 CLIENT_ERROR: repository not found for primary source [해결]buildspec.yml이 존재하지 않아서 생기는 문제COMMAND_EXECUTION_ERROR: Error while executing command: ./gradlew build. Reason: exit status 1[해결]Test Code문제 Kotest는 생성자를 받을 수 없으나, Spring은 필요로 한다 ➝ Spring 호환 관련 의존성 추가testImplementation(“io.kotest.extensions:kotest-extensions-spring:1.1.1”)https://jaehhh.tistory.com/118java.lang.ClassNotFoundException: org.gradle.wrapper.GradleWrapperMain [해결] gradle wrap 명령어를 buildspec.yml에 써 둘것!AWS Codedeploy agent -ruby 버전 문제 [해결]최신 ubuntu의 루비에서 호환성 문제가 생기며, 2.7번대의 버전은 설치가 불가능한 문제가 존재한다.ubuntu 20.04로 EC2 구축 요망Unable to access the artifact with Amazon S3 object key ‘iVOLVE-US-Server/BuildArtif/ZrALXLv’ located in the Amazon S3 artifact bucket ‘ivolve-us-server-deployment-bucket’. The provided role does not have sufficient permissions. [해결]EC2 - IAM 권한 부여를 통해서 codedeploy agent에게 정확한 IAM 권한을 부여해야한다.https://jojoldu.tistory.com/283https://gunbin91.github.io/aws/2020/01/10/aws_2_codedeploy.htmlwar jar 명령어 오타…, .war .jar 배포에 따른 쉘스크립트 차이이 두가지는 그냥 순수하게 오타의 문제이다. jar로 말고, 설정되어 있는걸 war명령어로 실행해서 계속해서 문제가 발생했다. 오타 주의" }, { "title": "[DevOps]아마존 AWS를 통한 CI/CD 구축 (with Github Actions)", "url": "/posts/CI-CD-with-aws/", "categories": "Tech, DevOps", "tags": "Tech, TIL, DevOps, AWS, Github", "date": "2022-09-16 17:51:35 +0900", "snippet": "📌 AWS의 CI/CD최대의 SaaS서비스인 아마존 역시 CI/CD 서비스를 제공한다. 젠킨스와 같이 다양한 커스터마이징이나, 개인 서버에 파이프라인 전체를 저장할 수 있지는 않지만, AWS의 다양한 Scalable한 서비스들과 함꼐 사용하면 커다란 시너지 효과를 낼 수 있다.📎 AWS를 이용한 CI/CD 파이프 라인초기에 생각했던 파이프라인은 다음과 같다. Github Actions를 통해서 빌드를 하고 빌드한 항목을 그대로 Deploy를 하는 방식이었는데, 이러한 방식을 선택하게 된 이유는 코드가 올라가는 깃허브 내부에서 Handle하는게 더 유용하다고 느껴졌다. AWS의 서비스들에 대한 지식이 부족했다.정도의 이유들로 정해놨다. 2편에서 작성하겠지만, AWS 측의 CI/CD 파이프라인 관리도 매우 훌륭해서, 충분히 활용한 여지가 있다는 것을 알고, 아예 전체 파이프라인을 AWS를 이용한 방식으로 잡아버렸다.사실 Github Actions를 많이 활용을 못해보았다. 거의 설계단계에서, 회사내에서 AWS사용에 훨씬 큰 이점이 있기 때문에, AWS로 거의 바로 넘어갔고, Github Actions는 스크립트 작성 시작 도중에 넘어가는 바람에 거의 활용하지 못해서, Github Actions는 개인적으로 공부를 할 예정이다." }, { "title": "[Kotlin]Kotlin + Spring을 사용기", "url": "/posts/Kopring-adventure/", "categories": "Tech, Kotlin", "tags": "TIL, Tech, Kotlin", "date": "2022-09-07 18:20:20 +0900", "snippet": "코프링 탐험기 🚵코틀린이라는 언어는, 스프링도 익숙하지 않은 나에게 굉장히 큰 도전이었다. 함수가 1급 시민이라는 점, 명시적인 Type과 Null-Safety도 어색했다. 겪어보면 코딩하면서 뜨던 많은 빨간줄들은 아마 자바를 사용하면서는 런타임에서 터질 오류였을지도 모른다.하지만 아직도 어색한 코틀린이기 때문에, 코틀린(정확히는 코프링)을 사용하면서 내가 기록하고 싶은 주의점들에 대해서 적어놓으려고 한다.Ko-Pring에서 생성자 주입 방법Java와 달리 Kotlin-Spring에서는 좀 다른 형태로 생성자를 주입하게 된다.Ko-Pring에서 Kotest를 사용해야 하는 이유Kotlin은 DSL의 적극적인 사용이 가능한 언어로, 일반적인 JUnit과 같은 JAVA기반의 테스트들은 반복적인 코드 사용으로 인해서 Kotlin의 강점이 많이 빛바랜다.Junit에서 자주 사용되는Kotest 작성시 zero - argsKotest는 기본적으로 argument를 따로 받지 않는다, 하지만 스프링에서 생성자를 주입한다던지 다른 주입을 위해서 생성자단에 입력해줘야 할 때, zero - args 오류가 뜨게 된다.그 외의 오류들spring.jpa.hibernate.ddl-autoJPA 와 SQL 구문 충돌 HEX코드로 저장되어서 Padding값이 지정되어 있는 모습 https://dblog94.tistory.com/entry/JPA-UUID%EB%A1%9C-findBy-%EC%A1%B0%ED%9A%8C%EA%B0%80-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0" }, { "title": "[PeachTri] CI/CD 설정하기", "url": "/posts/CI-CD/", "categories": "Blogging, PeachTri, Iride-Scent", "tags": "세미나, PeachTri, DevOps, Iride-Scent", "date": "2022-08-26 00:20:00 +0900", "snippet": "📌 CI/CD?📎 코드는 만들고 끝일까?우리가 코딩을 하다 보면 완성하고 끝!인 경우가 참 많다. 특히 어디에 배포를 하거나 서비스를 계속해서 유지하고자 하는 경우가 아니라면 더욱 그렇다. 하지만, PeachTri가 이루고자 하는 목표는 지속 가능한 서비스이다. 지속적으로 유지보수되고, 문제없이 서비스가 지속되기 위해서는 CI/CD가 꼭 필요하다.📎 CI/CD란?CI/CD는 Continuous Intergration (지속적 통합) / Continuous Deployment (지속적 배포)의 약자로써 다수의 개발자가 하나의 코드를 수정해도 계속적으로 통합관리되먀, 이 통합 관리된 코드가 계속해서 신뢰성 있게 배포되도록 하자는 개념이다.🤝 Continuous Intergration 지속적 통합코드의 품질이 관리될 수 있는 것을 뜻한다. 이러한 CI프로그램들은 코드가 깃의 브랜치에 병합되면 자동으로 빌드와 테스트를 통해서 검증한다. 해당 코드에 잠재적인 문제는 없는지, 구문문제와 같이 쉽게 발생 가능한 문제들에 대해서도 바로바로 찾아서 알려준다. 이러한 프로그램을 통해서 개발자는 코드를 작성하고 일일이 빌드 테스트를 하지 않아도, 혹은 임의의 테스트나 빌드에서 미처 걸러지지 못하는 문제들도 배포하기 전에 알 수 있게 된다.🪂 Continuous Deployment지속적 배포는 소프트웨어가 지속적 통합을 거치고 난 이후에도 신뢰할 수 있고, 바로 배포할 수 있는 것을 말한다. 이미 코드가 CI를 통하여 저장소에 업로드 되어 있다면, CD는 이를 배포환경으로 릴리즈 한다. 배포환경에서 발생할 수 있는 문제를 확인하고 문제가 없다면 정식 버전으로 배포를 진행하게 된다.🧰 어떤 툴을 사용할 것인가?우리는 소나큐브 + 젠킨스를 통해서 CI/CD환경을 구축하기로 했다.현업에 있는 팀원이 추천한 조합이며, 강력한 CI/CD툴인 젠킨스와 구문분석 툴인 소나큐브를 합치면 분명히 우리 팀에게 있어서도 효과적일 것이라고 생각된다.특히나 비용 하나만으로도 충분히 부담이 될 수 있는 소규모 프로젝트에서, 무료이면서 정보도 상당히 많은 젠킨스의 장점이 크며, 소나큐브 또한 오픈소스 프로젝트임의 장점이 존재한다. UI를 통한 대시보드도 지원한다는 장점이 존재한다.깃허브와 젠킨스, 소나큐브깃허브, 젠킨스, 소나큐브를 통한 다음과 같은 파이프라인으로 CI/CD를 이용할 계획이다.🤖 자동화는 최고야imageCI/CD파이프 라인까지 마무리 했고, GCP상에 존재하는 리눅스에 환경을 설정해야한다. 이런저런 글에 올라온 내용은 참 쉽지만, DB테이블 생성에서도 그랬듯이, 험난한 과정이 예상된다. 인턴과정과 함께 병행하는게 부담되지만(사실 그렇게 막 미친듯이 푸쉬하는게 아니긴 한데, 인턴과정과 스터디를 병행하면서 정말 짧은시간동안 지식이 미친듯이 들이칠 예정이다!) 잘 해내리라고 생각된다.참고자료CI/CD가 뭔가요? - 이론편" }, { "title": "[PeachTri] DB 생성", "url": "/posts/DB-Settings/", "categories": "Blogging, PeachTri, Iride-Scent", "tags": "세미나, PeachTri, DB, Iride-Scent", "date": "2022-08-22 12:00:00 +0900", "snippet": "💻 DB를 생성해보자!저번주에 전체적인 테이블의 RDB 구조를 작성했다. 이번주 세미나는 같이 직접 MySQL테이블을 생성하는 스크립트를 작성해보았고, 그 과정에서 우리가 겪었던 어려움에 대해서 기록해보려고 한다.📌 잡다한 오탈자사실 잡다한 오탈자는 너무나도 자주 발생한다. 다른 언어의 스니펫같이 자동완성을 어마어마하게 지원하지도 않고, 오탈자가 자주 발생할 만한 단어들이 산재해 있기 때문에 끊임없이 마주치게 되는 오탈자가 첫번째 문제였다. 또, CREATE 'TABLE'을 뺴먹는 경우도 존재하여서 시간을 크게 소모했다.📌 TIMESTAMPsql에서 삽입,수정을 한 주체와 시간을 로그로 기록하기 위해서 타임스탬프값을 DB내에서 지정했다. 이 과정에서 TIMESTAMP의 몇가지 특징을 메모하려고 한다. TIMESTAMP는 디폴트 값이 존재해야한다.MODIFIED_TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,따라서 다음과 같이 수정한 날짜에 대해서 현재 값을 DEFAULT로 저장하는 방식으로 스크립트를 작성했다. TIMESTAMP는 기본적으로 NOT NULL이다.그래서 TIMESTAMP에서 따로 NOT NULL을 지정해줄 필요는 없고, 그냥 NULL인 경우만 옆에 조건으로 적어주면 된다.📌 복합기본키다음과 같이 다른 테이블들의 기본키들을 외래키로 가져와 unique한 기본키들로 사용해야 하는 경우, 둘 다 Primary Key로 지정하게 되면 오류가 발생한다. 이런 경우 단순하게 둘 다 Primary Key로 지정하는 것이 아니라, 제약조건을 통해서 지정해줘야 한다.CONSTRAINT BLEND_PK PRIMARY KEY (PERFUME_ID, PERFUMER_ID)다음과 같은 쿼리 문으로, 사용할 제약조건의 이름BLEND_PK와 함께 이 제약조건에 들어갈 기본키 두개를 지정해주면, 두 키의 조합 자체가 unique하게 된다.📌 auto_increment 문제굉장히 편리한 기능인 auto_increment는 사용하지 않기로 했다.메모리에서 동작하는 innoDB에서 초기화 되는 문제가 발생하기도 하거니와 여러가지 테이블 락 등의 문제가 존재하여서, 직접 인덱싱을 하는 방향으로 결정했다.또한 향수 이름이나 향수 회사이름이 정말정말정말 긴 경우가 많아서 자료형에서 VARCHAR의 길이를 정하는데 고민이 좀 있었던 것 같다. fragrantica사이트에서 충분한 검토후 선정하였다.🤦 아직 공부중인 문제다음과 같이 MySql내부의 파일에 접속시 function&gt;만 덩그러니 놓여있는 오류도 존재했는데 원인을 찾을 수 없었다. 구글링에 정상적인 MySQL실행 방법이라고 하는데, 나의 경우 적용되지 않았다.#📖 참고자료https://blog.naver.com/PostView.naver?blogId=sory1008&amp;logNo=222346919445&amp;parentCategoryNo=&amp;categoryNo=79&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postViewhttps://yun5o.tistory.com/entry/MySQL-AUTOINCREMENT-%EC%9E%90%EB%8F%99%EC%A6%9D%EA%B0%80-%EA%B0%92-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0https://abbo.tistory.com/208" }, { "title": "[GIT] Git에서 Branch Merge 하기", "url": "/posts/Git-merge/", "categories": "Tech, GIT", "tags": "TIL, Tech, GIT", "date": "2022-08-22 12:00:00 +0900", "snippet": "📌 GIT Merge!Git을 사용하다보면, Branch를 나누게 되고, Branch를 나누고 병합하는 과정을 꼭 해야하는 경우가 있다.이번에 Spring 핵심을 공부하면서, 이미 만들어진 자바파일과 깃허브에 README파일만 넣고 미리 파놓은 repo를 병합하면서 잠깐 해메던 내용과 솔루션을 공유할겸 메모하려고 한다.📎 원격 저장소를 병합하기 위한 과정첫번째로 병합할 원격 저장소를 추가해줘야 한다.$ git remote add &lt;병합할 원격 저장소 이름&gt; &lt;병합할 원격 저장소 주소&gt;다음과 같이 원격 저장소의 주소를 지정해줘서 이미 존재하는 로컬 저장소와 원격 저장소를 연결해준다.$ git fetch &lt;병합할 원격 저장소 이름&gt;원격저장소의 커밋 기록들을 가져온다. 원격 저장소의 커밋들을 가져와 파일 이름은 문제가 없는지 확인한다. 내용이 같다면 그냥 pull명령어를 실행해도 되지만, 만약 그렇지 않다면 fetch후 merge를 하는 것이 안정성이 높다.📎 기록들을 병합$ git merge --allow-unrelated-histories &lt;병합할 원격 저장소 이름&gt;/&lt;병합하고 싶은 원격 저장소의 branch 이름&gt;그냥 git merge를 하게 되면 이전 커밋기록과 연결이 되지 않아서 merge자체가 잘 되지 않는다. 이때 좋은 방법이 --allow-unrelated-histories 옵션이다. 커밋기록도 병합하도록 허용하는 옵션으로 push시에도 유용하게 사용할 수 있다.이후, remote remove를 통해서 이미 존재하던 저장소를 지우고, Local의 저장소를 커밋하면 된다.위의 과정중 가장 중요한 과정이 바로 병합과정이라고 생각한다, merge명령어 중에서 커밋기록이 연결되지 않는다는 사실을 모른다면 아마 해결하지 못했을 것이라고 생각한다.📖 참고자료https://velog.io/@www_1216/%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EB%91%90-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C-%EB%B3%91%ED%95%A9%ED%95%98%EA%B8%B0https://cheonmro.github.io/2019/04/13/merge-branches/" }, { "title": "[BLOG] Git vs Perforce", "url": "/posts/Git-VS-Perforce/", "categories": "Tech, Theory", "tags": "TIL, Tech", "date": "2022-08-16 12:00:00 +0900", "snippet": ":pushpin: Git vs Perforce 상태관리 툴을 비교해보자학교의 졸업 프로젝트를 진행할 때, 게임 개발이다 보니 Git이 아닌 다른 방식으로 상태관리를 하고 싶었다.항상 개인 프로젝트를 할 때 Git을 이용해서 상태관리를 했지만, 과연 Perforce라는 다른 툴, 그것도 내가 직접 AWS에 서버를 파서 관리하는 상태는 어떤 느낌일지에 대해서 좀 적어보려고 한다.📎 편의성의 GitGit은 일단 무료라는 점이 엄청나게 매력적이다. 자그마한, 그것도 아직 수익이 따로 발생하지 않아서 추가적인 비용이 발생하는 것이 두려운 개인 개발자들에게 Git은 정말 매력적인 도구라고 생각한다. 커다란 규모의 인원이 아닌 소규모의 인원들로도, 충분히 버전의 최신화에 관해서 관리할 수 있기 때문에 Git - Github로 이어지는 조합이 참 매력적이라고 생각한다.VScode등의 툴과 척척 붙는 것도 장점이고, CLI를 이용한 이용법을 찾는게 정말 쉽다는 장점이 있다.(터미널을 이용해서 정말 빠르게 컨트롤이 가능하다.):paperclip: 규모의 PerforcePerforce는 규모있고 다양한 큰 파일을 관리하기 정말 편리하다. 이 장점만 봐도 게임개발에 적합하다는 것을 알 수 있다. 다양한 파일과 트렌젝션들, 파일들의 용량에 대해서 아무리 크고 잦은 변화라도 빠르게 반영한다. 또한, 각 파일들에 대해서 개발자들이 독점적으로 Lock을 걸고 사용하기 때문에 Step이 엉키는 경우가 없었다.또한 언리얼에서 자체적으로 밀어주는 점이 있다 보니, 퍼포스가 언리얼과 잘 붙어 다니는 점도 매력적이었다. 3명이라는 적은 팀원이었지만, 다양한 방식의 상태관리를 체험하고 싶어서 사용하게 되었다. AWS를 통해서 매달 비용이 들어가는 부분이 있었지만, 그 부분을 감수하고서라도, 개발경험이(특히나 게임이) 많지 않았던 우리 팀에서 많은 소음 없이 게임을 개발할 수 있었다고 생각한다.Perforce의 단점이라고 한다면 CLI가 상대적으로 매우 안좋다는 점이다. AWS에서 연동해서 AWS자체에서 문제를 처리한 경우가 훨씬 많다. 완전히 파일을 갈아 엎는 경우에도 AWS 콘솔 상에서 퍼포스 저장소를 지우고 새로 파는 경우가 훨씬 잦았다.🤦 Perforce vs Git가장 중요한점은 Perforces는 중앙서버에 커밋이 등록 된다는 것이고, Git은 Reop단계의 권한이 찢어지 경우 상호 의존성 문제가 발생할 수 있다는 점이다. 또한 짧은 시간동안 계속해서 커밋이 일어나는데, 그것에 대해서 실시간으로 빠르게 반영할 수 있는 (특히나 커다란 용량의 파일들) Perforce가 좋다고 생각했다. 실제로 적용해보니, CheckOut이라는 시스템이 불편하지만, 또 이 CheckOut이라는 점이 안정적으로 게임을 개발할 수 있었다고 생각한다.간단하게 Refresh만 해줘도 이미지부터 모델링까지 많은 파일들이 안정적으로 관리되어서 Unreal을 이용하는 개발자라면, 한번쯤은 이용해봐도 참 좋은 시스템이라고 생각한다.단점은 Git에 비해서 문제점 해결이 쉽지 않았다. 이유없는 버전이슈나 접속이슈들(대게는 개개인의 컴퓨터 네트워크나 방화벽 문제였던 것으로 기억한다.) 혹은 무료티어인 헬릭스로 인해서 생기는 문제들이 좀 있었지만, 잘 핸들링 해서 결국 제출까지 이어질 수 있었다." }, { "title": "[PeachTri] PeachTri GCP와 DB 설정", "url": "/posts/Peach-Tri-GCP-and-DB/", "categories": "Blogging, PeachTri, Iride-Scent", "tags": "세미나, PeachTri, DB, Iride-Scent", "date": "2022-08-11 23:26:00 +0900", "snippet": "GCP Google Cloud Platform 우리는 파이어베이스라는 쉬운 길을 버리고 어려운 길을 선택했다.먼저 데이터베이스를 올릴 클라우드 서비스를 선택했다. 프로젝트에서 AWS를 선택한 것과는 다르게 이번에는 Google Cloud Platform 을 통해서 진행하기로 결정했다. ~무료 티어가 있다는 이야기를 시작으로 GCP에 더 이끌린 느낌도 있지만~, aws에서 이미 퍼포스등을 통한 환경 설정을 해본 나는 GCP라는 새로운 플랫폼을 통해서 설정해보고 싶다는 생각이 들었다.GCP 설정GCP에 EC2 VM을 하나 설정하여서 서버로 사용할 계획이다.키를 통해서 접속도 가능하지만, 비밀번호를 통한 손쉬운 SSH접속을 위해서 팀원 3명의 게정을 생성하여서 SSH 접속을 시도 하였다.sudo passwd와 adduser명령어를 통해서 인원을 추가했다.GCP 방화벽 설정GCP는 다양한 가상머신을 병렬적으로 다뤄야할 상황을 상정하여서 규칙을 생성하고 그곳에 태그를 정하여, 해당하는 태그를 가진 VM들이 규칙을 따르도록 설정한다.인그레스와 이그레스에 대한 SQL포트 3306에 대해서 모든 ip들(0.0.0.0/0)들의 접속을 허용하도록 설정을 잡았다. 해당하는 설정을 통해서 DBeaver와 SQL 클라이언트가 SSH키 없이 접속할 수 있도록 설정을 잡아주었다.리눅스 포트 접근 허용하기GCP의 방화벽 설정을 했으면, GCP안에 리눅스에서도 포트접근을 허용해야 한다.sudo iptables -I INPUT -p tcp -m tcp --dport 22 -j ACCEPT와 sudo iptables -I OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT명령어를 통해서 mysql이 사용하는 22번포트의 인풋 아웃풋을 허용하는 규칙을 설정해준다.Connection refused:connectsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf명령어로 MySQL설정 파일을 연다.다음과 같은 두 항복이 루프백 주소로 되어 있어서 외부의 접속을 막고 있는데, 이를 주석처리 하거나 완전히 오픈하여서 외부의 다른 IP도 접속할 수 있도록 설정을 잡아줘야한다.MYSQLDB는 MySQL을 사용하기로 했다. PostgreSQL의 조금이라도 존재하는 러닝커브를 피하기 위함이다.(현재 생각중인 Flutter, Spring 모두 공부를 필요로 한다.).SQL에서도 비밀번호를 통해서 접속하기Connection refused : connect, Public Key Retrieval is not allowed8.0이상의 DBeaver에서는 주소값과 드라이버이름, 유저아이디, 패스워드만 가지고는 에러가 발생한다.드라이버 설정의 AllowPublicKeyRetrival 옵션을 true로 바꾸면 해결할 수 있다.다만 이러한 키 방식의 번거로움을 줄이고자 비밀번호를 통하여 유저를 인증하는 Authentication Plugin을 사용하기로 했다.MySQL 8.0부터는 기본적인 authentication plugin이 caching_sha2_password이 되면서 RSA key를 필요로 한다. 단, 이러한 key를 이용한 방식이 아닌 단순 암호를 사용하는 방식으로 바꾸기 위해서는 다음과 같은 코드를 사용해야한다.CREATE USER 'nativeuser'@'localhost'IDENTIFIED WITH mysql_native_password BY 'password';혹은ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'test'flush privilages;다음과 같은 query를 통해서 mysql_native_password를 사용할 수 있다.역시 환경설정이 제일 어려운법환경설정은 항상 느끼지만 어렵다. 나의 발목을 잡는다는 느낌이 드는 것도 당연하다고 생각한다.Firebase를 사용한다면 이런 오류를 만나지 않았겠지만, 만나지 않았기 때문에 조금은 더 성장했다는 느낌을 받았다.앞으로 DB의 세부 테이블이나 내용은 다음주에 또 다뤄보도록 하겠다." }, { "title": "[BLOG] Jekyll 테마 오류 수정", "url": "/posts/fixing_jekyll_error/", "categories": "Blogging, Chat", "tags": "Blog, Github, Issues", "date": "2022-08-11 14:54:10 +0900", "snippet": "깃허브 블로그 테마를 jekyll-theme-chirpy로 바꾸면서 다음과 같은 에러가 계속해서 발생했다.내가 변경하려는 테마는 기본적으로 CI/CD가 설정되어 있어서 블로그 설정이 제대로 되어 있지 않다면 동작하지 않는다는 것을 알았다.다음과 같이 커밋되는 코드를 검토하여서, 해당하는 코드가 문제가 없을때만 gh-pages라는 브랜치로 푸쉬되어서 실제 페이지에 반영된다.이러한 과정이 반영되지 않아서 테마가 적용되지 않고 index.html의 내용이 날것 그대로 보여지는 것이었다.원인이 무엇일까? 🔨나의 경우는 Gemfiles.lock을 gitignore에 반영하지 않아서 생기는 문제였다. 해당하는 파일을 gitignore에 올려주니 제대로 커밋되었다.또한, 프로필 사진으로 올려둔 PNG이미지가, config파일에서 호출했지만, 디렉토리상에 실제로 넣어두지 않아서 오류가 발생한 부분도 있었다.커밋되었을때 ✅ 가 잘 뜨는지 까지 확인하고 문제가 생긴다면 배포 어느 부분에서 문제가 생겼는지 확인해야 한다. 편안~깃허브 블로그는 항상 손 댈때마다 문제가 조금씩이라도 발생한다. 🤦" }, { "title": "[PeachTri] PeachTri 어떤 DB를 사용해야 할까? - 2", "url": "/posts/Peach-Tri-Which-DB-should-we-use-2/", "categories": "Blogging, PeachTri, Iride-Scent", "tags": "세미나, PeachTri, DB, Iride-Scent", "date": "2022-08-10 22:02:00 +0900", "snippet": "사용해야할 DBSQL우리는 기본적으로 향수에 대하여 정리하고, 정리된 데이터를 기반으로 향수를 추천하는 어플리케이션을 제작할 예정이다. 이에 따라서 다양한 방식을 살펴볼 수 있는데, 내가 1차적으로 생각하는 것은 SQL형식의 RDB이다.왜 RDB인가?기본적으로 noSQL에 대해서 팀원들의 전체적인 이해도가 없다. 이에 가장 큰 걱정인 것은, noSQL의 러닝커브 대비해서, 어플의 성능문제나 noSQL에 대해 들어가는 공부의 비용이 어플리케이션을 만들면서 들어오는 이점 대비 너무 크다는 점이었다. 대한민국 대부분의 서비스들이 RDB형식으로도 충분히 만들 수 있고, 각각의 향수에 대한 데이터가 RDB로도 충분하기 때문에 RDB로 하는 것을 고려해 볼 생각이다.어떤 RDB를 사용할 것인가?RDB는 다양한 종류가 존재한다. 다음은 대표적으로 사용하는 RDB들이다. Oracle 오라클에서 개발한 RDB로 가장 많이 사용한다. 중앙 집중 방식이고, 다양한 기능을 재공하며, 장애에 대처가 유연하다. 기본적으로 큰 비용이 발생한다. MySQL 오픈소스에서 파생되어서 현재는 오라클로 넘어갔다. 경량의 장점이 있으나, 기능확장이 되면서 다른 RDB들과 비슷해졌으며, 오라클로 넘어가서 라이센스 문제가 생겼따. Microsoft SQL SERVER 엔터프라이즈급 관리 비싼 가격, Windows기반 서버 전용 MariaDB MySQL의 라이선스 상태에 반발하여 만들어진 오픈소스프로젝트 MySQL에 비해서도 빠르며, 다양한 기능을 제공하고, MySQL보다 잘 관리되고 업데이트되며, 오픈소스 특성상 많은 이용자들이 존재한다. PostgreSQL MariaDB와 같은 오픈소스 프로젝트 멀티 프로세스 방식으로 복잡한 쿼리나 join처리에서 좀 더 뛰어난 성능을 보여준다. 상당히 높은 점유율로 인해서 정보를 찾기 편하다.다음과 같은 RDB들 중에서 PostgreSQL를 추천해볼까 한다. 오픈소스 프로젝트라는 점, 그래서 이용자도 많다는 점, 정보나 업데이트도 빠르기 때문에 우리의 토이프로젝트 적용에도 매우 좋을 것으로 생각이 든다. " }, { "title": "[PeachTri] PeachTri 어떤 DB를 사용해야 할까? - 1", "url": "/posts/Peach-Tri-Which-DB-should-we-use-1/", "categories": "Blogging, PeachTri, Iride-Scent", "tags": "세미나, PeachTri, DB, Iride-Scent", "date": "2022-08-08 20:05:00 +0900", "snippet": "어떤 데이터 베이스를 사용할까?Iride-scent는 현재 내가 속한 토이프로젝트 팀 PeachTri가 현재 기획하고 제작에 들어가려고 하는 향수 추천 어플리케이션이다. 이런 추천 서비스를 위해서는 향수의 노트나 제작에 들어가는 재료와 같은 여러가지 데이터의 입력을 필요로 한다. 그래서 우리 팀은 어떠한 DB가 우리 어플리케이션 특성에 맞춰서 적용할 수 있는 DB인지를 파악해보려고 한다.저장을 필요로 하는 데이터는 어떤 것들이 있을까?우리 어플리케이션 Iride-scent는 향수 추천 어플리케이션으로 기본적으로 다음과 같은 정보들을 저장할 것을 목표로 했다 향수 이름 조향사 노트 재료 향수의 특성 일차원 적으로 이러한 향수의 정보들을 먼저 저장하고, 향수의 재료와 향수의 특성을 토대로 유사한 향수들을 추천하는 방식으로 어플리케이션을 디자인 하였다.차후의 이런 어플리케이션에서 로그인을 통한 유저 정보가 저장된다면 다음과 같이 확장되게 된다. 유저 향수 리뷰 이용한 향수 추천도 (평점) 시향 후 선호도나 좋아요 정보 등등 아마도 이러한 정보를 비롯하여서 다른 이용자에게도 추천을 할 수 있도록 넘어가는 방식으로도 생각해 볼 수 있다.일단 지금 당장의 기능은 위의 향수를 비롯한 유사 향수의 추천이며, 로그인을 이용한 유저기능은 또 다른 문제이기 때문에 핵심 기능인 향수추천에 대해서 먼저 집중하려고 한다.RDB? NoSQLRDB은 관계형 데이터 베이스로 전공에서 흔히 배우는 mySQL과 같은 데이터 베이스를 뜻한다. DB가 형태가 굉장히 견고하며, 열과 행이 애트리뷰트와 레코드를 나타내는 테이블 형식의 데이터 베이스인 RDB는 CRUD 명령어를 통해서 조작하며, 널리쓰이는 형태의 DB이다.반면 NoSQL은 이름 그대로 SQL을 이용하지 않는 데이터 베이스이다. 고정되지 않은 테이블 스키마를 이용하며, RDB에 비해서 훨씬 커다란 용량의 데이터 베이스를 저장할 수 있는 형식이다.RDB MySQL MariaDB Oracle PostgreSQLNoSQL MongoDB Couchbase Cassandra다음과 같이 DB들에 대한 조사를 마치고, 어떤 DB를 사용할지 팀원들이 함께 조율중이다.# 선택은 항상 신중해야 한다항상 고민되는건 테크스택이라고 생각한다. 오히려 개발할 때 보다 더 신경쓰이고 고민된다. 우리의 서비스에 어떤 방식이 어울릴지, 어떤 개발방식이 더 유연할지에 대해서, 즉, 미래에 대해서 고민하는 과정이라고 생각한다. 그래서 더 신경쓰인다고 생각이 든다. 단, 레거시는 항상 생긴다. 서비스는 유지보수되고 언젠간 낡은 것이 되어 고장난 곳을 고쳐야 한다. 생명체와도 같은 프로그램을 잘 설계하는 것도 중요하지만, 적절하게 설계를 끝마치고 추진력을 가지고 개발을 완료하고 잘 유지보수 하는 과정도 중요하다고 본다." }, { "title": "[JAVA] JAVA의 Thread", "url": "/posts/JAVA-Thread/", "categories": "Tech, JAVA", "tags": "JAVA, TIL", "date": "2022-07-08 19:48:20 +0900", "snippet": "자바의 ThreadThread프로세스는 프로그램의 실행 단위로, 프로세스를 다중으로 실행하게. 되면 그 크기가 크고, 메모리 공유에 있어서 단점이 존재하기 때문에, Thread를 통해서 프로그램을 실행하는 것이 프로세스보다 자원을 덜 소모하면서도 효율적으로 멀티 태스킹이 가능하게 된다.Runnable vs Thread자바에서 Thread는 Thread 클래스를 상속 받는 것과, Runnable 인터페이스를 implements하는 것 두가지로 나눌 수 있는데, 각각의 장단점이 존재한다.runnable 객체는 스스로 Thread가 아니기 때문에, Thread객체를 생성하고, 그 생성자에서 다시 Interface를 통해 Runnable 객체를 생성해줘야한다.Thread 클래스 확장법public class MyThread extends Thread{\t@Override\tpublic void run(){\t}}Runnable implements 방법public class MyRunnable implements Runnable{\t@Override\tpublic void run() {\t}}구현부public class ThreadExam {\tpublic static void main(String[] args) {\t\tThread thread1 = new MyThread();\t\t\tThread thread2 = new Thread(new MyRunnable());\t\tThread thread3 = new Thread(()-&gt;{원하는 구현});\t}}thread3과 같이 람다식을 통해서 간결하게 구현할 수 있다.동기화 메소드public synchronized void PrintLine() {\tfor (int i = 0; i &lt; 10 ; i ++) {\t\tsynchronized(this){\t\t\tSystem.out.println(\"라인을 프린트합니다.\");\t\t}\t}}synchronized 키워드를 통해서 객체를 공유하는 다른 쓰레드의 메소드과 동시에 호출되는 것이 아니라, 해당 부분이 실행되는 동안은 다른 메소드들이 호출되지 않고 해당하는 메소드가 먼저 객체를 사용하고 다른 메소드는 기다리도록 모니터링 락(Monitoring Lock)을 획득하여 실행된다.join()join메소드는 쓰레드를 실행하고, 실행된 쓰레드가 종료될 때 까지 다른 쓰레드는 기다린다." }, { "title": "[JAVA] 회원관리 예제", "url": "/posts/Member-Management/", "categories": "Tech, JAVA, Spring", "tags": "JAVA, TIL, Spring, JPA", "date": "2022-07-07 12:44:00 +0900", "snippet": "회원 도메인과 리포지토리 만들기Optional은 java8에 들어간 기능으로, NPE오류로 부터 자유롭게 만들어준다.MVC 패턴을 통해서 회원 도메인과 리포지토리를 생성한다.HelloController를 통해서 매핑을 받고 API 형태로 리턴하도록 만든다.MemberRepository를 통해서 MemberRepository의 인터페이스를 생성한다.MemoryMemberRepository를 통해서 위에서 작성한 인터페이스를 구현한다.sequence는 키값을 생성해준다.회원 리포지토리 테스트 케이스 작성cmd - alt - V ⇒ 변수 추출하기cmd - shift - T ⇒ 해당 클래스 테스트 클래스 생성cmd -alt -M extract methodctrl - T refactoring회원 서비스 개발repository를 가져오고join이라는 메소드를 생성한다.optional로 한번 감싸서 받게되면, if문을 따로 사용하여 활용할 필용 없이. ifPrsent 통해서 입력된 이름으로 존재하는그리고 validateDuplicateMember(), findMembers()와 findOne()메소드도 생성해준다.회원 서비스 테스트테스트 코드 작성시에 테스트 이름을 한글로 작성해도 상관없다.클래스의 빈 곳 아무곳에나 오른쪽 마우스를 클릭해서 create test하면 손 쉽게 테스트를 생성할 수 있다.try{ memberService.join(member2); fail();} catch (IllegalStateException e) { assertThat(e.getMessage().isEqualTo(\"이미 존재하는 회원입니다.\"))}@어노테이션을 통해서 의존관계를 주입하는 것을 컴포넌트 스캔방식이라고 한다.@Component 에노테이션이 있으면 스프링 빈에 등록됨, @Component를 포함하는 @Service @Repository @Contoroller도 스프링빈에 등록한다. 단순히 @Autowired 에노테이션으로는 스프링이 관리하지 않는다.실행하는 어플리케이션의 같은 패키지만 스캔한다.따로 @Configuration이라는 에노테이션을 통해서 config 클래스 내부에 @Bean 에노테이션을 통해서 연결할 수도 있다.자바 설정파일을 직접 설정하는 경우, 한 파일 내에서 연결을 관리할 수 있다는 장점이 있다.@Transcational 에노테이션으로 각 부분 테스트가 끝나고 DB를 롤백하는 방식으로 테스트 한다.가급적으로는 순수한 단위테스트가 훨씬 좋은 테스트일 확률이 높다.JDBC템플릿은 템플릿 디자인 패턴을 활용해서 순수 JDBC에서 반복 코드를 많이 제거한 버전이라고 생각하면 편하다.JPAORM Object Relational Mapping어플리케이션의 Class와 RDB의 테이블을 매핑한다는 뜻이며, 객체와 RDB 테이블을 자동으로 영속화 해준다고 생각하면 된다.pros 메서드를 통해서 DB를 조작할 수 있음 (비즈니스 로직에 집중) 쿼리가 필요로 하는 선언문이 생략되어서 가독성이 높아짐 유지보수와 리팩토링에 유리하고, 객체지향적인 코드 작성이 가능함 DB특히나 상속관계가 존재하는 클래스와 상속관계라는 개념이 존재하지 않는 DB Query에서 이 사이의 패러다임 차이를 연결해 주는 것이 바로 JPA다JPA + Spring JAP + Querydsl(동적 쿼리)복잡한 경우는 Native쿼리를 통해서 SQL을 작성한다.AOP Aspect Oriented Programming핵심 비즈니스 로직 외의 핵심 관심 사항은 아니지만, 공통의 관심 사항인 경우에 필요로 한다.모든 메소드의 실행 시간을 측정하는 경우, 모든 비즈니스 로직들에 다 섞어줘야 하고, 유지보수도 힘들고, 별도의 공통 로직으로 만들기 매우 어렵다.기존의 의존관계는컨트롤러 → 서비스 이지만AOP 적용 후에는컨트롤러 → 스프링 컨테이너를 통한 프록시 → 실제 서비스DI를 통해서 helloController는 DI를 통해서 Injection을 받기 때문에 프록시로 바꿔치는 방식으로 사용할 수 있다." }, { "title": "[JAVA] Spring 프로젝트 환경설정", "url": "/posts/Spring-Project-Settings/", "categories": "Tech, JAVA, Spring", "tags": "JAVA, TIL, Spring", "date": "2022-07-03 01:02:00 +0900", "snippet": "start.spring.io를 통해서 스프링 부트로 스프링 프로젝트 생성프로젝트 호환성 관리는 메이븐이나 그래들 사용하는 툴을 통해서 생성.Spring boot 버전은 SNAPSHOT과 M$버전은 테스트중인 경우가 많으므로, 다른 꼬리말이 없는 stable 버전으로 생성group은 보통 기업이름Artifact는 빌드될 때 나올 결과물다운 받고 나서, 인텔리 제이에서 open or import를 통해서 gradle 파일을 열어서 연다.기본적으로 gradle로 자동으로 Depedencies를 설정해주면서. main매서드를 실행하면 Tomcat이라는 웹서버를 띄우면서 스프링 부트도 올라오며 포트 8080에 사이트를 연다.라이브러리 살펴보기maven이나 gradle은 의존관계를 설정해준다. 단순한 의존관계가 아니라, Spring web이 필요로 하는 의존 그 의존을 물고 물어서 스프링 코어까지 땡겨온다.예전에는 서버에 웹서버를 설치하지만, 요즘은 소스에서 웹서버 실행 자체를 가지고 있다.핵심 라이브러리 스프링 부트 스타터 웹 톰캣 MVC 타임리프 스프링 부트 + 스프링 코어 + 로깅 spring boot spring core spring boot starter logging logback slf4j 테스트 라이브러리 spring - boot starter test junit 테스트 프레임 워크 mockito 목 라이브러리 assertj 테스트 코드 작성 도와주는 라이브러리 spring test 스프링 통합 테스트 지원 View 환경설정src - java - resources - static해당 경로에는 정적 페이지가 들어간다.웹 브라우저에서 경로/hello 가 넘어오면, 스프링부트에 내장된 톰캣 서버가 스프링에게 hello를 물어본다.그러면 스프링은 코드들중에서 GetMapping(”hello”)를 찾고, 모델로 넘어와서 addAttribute로 키와 벨류를 만들고 hello 라는 이름으로 return한다. hello라는 이름을 들고 hello.html에게 넘긴다.스프링 부트 템플릿 엔진 기본 view mappingresources:templates/ {name}.html해당 폴더의 ./gradlew build로 빌드build/libs/에서 java -jar 빌드된파일.jar를 실행해서 띄운다.정적 컨텐츠간단한 설명웹 브라우저가 톰캣 서버에게 html을 요청하면, 톰캣 서버는 스프링 컨테이너에 해당하는 컨트롤러가 없는 것을 확인하고, 리소스에서 static에 존재하는 것을 톰캣이 확인하고 톰캣이 리턴한다.컨트롤러가 우선순위를 먼저 가지고 정적 컨텐츠가 가진다MVC와 템플릿 엔진@RequestPara을 통해서 파라미터를 요청하고 리턴한다.타임 리프는 th태그의 내용을 작동시키고, 값이 없으면 정적인 내용을 보여준다.intelilj에서 cmd+p로 파라미터 정보를 볼 수 있다.uri에 ?name=spring 이라고 하면 파라미터가 name의 키에 값을 spring으로 바꾼다.웹브라우저가 톰캣에게 요청을 보내면, 톰캣은 요청을 컨트롤러에 있는것을 보고 넘긴다. 그러면 컨트롤러는 모델을 변환해서 viewResolver가 타임리프를 통해 전환을 하고, 변환하고 웹브라우저에게 톰캣을 통해 보낸다.API@ResponseBody를 통해서 html body부에 데이터를 직접 넘겨준다는 의미를 가진다. → HTML의 마크업 없이 return에 데이터를 그대로 보낸다.Getter와 Setter를 통한 자바 bean 규약(property 접근방식)을 통해서 생성한다.만약 @ResposeBody를 보면 viewResolver를 사용하지 않고 바로 던지는데, 객체라면 Json Converter나 StringConverter를 통해서 컨버팅을 하고 던진다.클라이언트의 Accept헤더를 조합하여서 xml과 같은 JSON이외의 형태로 전달할 수 있다." }, { "title": "[PeachTri] PeachTri 다섯번째 세미나 - 플러터의 상태관리", "url": "/posts/Peach-Tri-5th-seminar/", "categories": "Blogging, PeachTri, Seminar", "tags": "세미나, PeachTri", "date": "2022-07-01 18:12:00 +0900", "snippet": "상태관리는 무엇인가?component를 통해서 class의 state가 관리되는 형태의 플러터는, 자식컴포넌트들 간의 데이터를 주고 받는 과정에서 불필요한 이동을 줄이고 비즈니스 로직과 위젯을 분리하기 위해서 필요로 한다.Bloc가장 널리 쓰이는 상태관리 솔루션, Google에서 개발되었으며, UI와 Bussiness Logic을 분리하여서 의존성을 낮춘다.장점 비즈니스 로직과 구현부를 나누기 쉽다. 예시자료가 정말 많다 의존성 주입 플러터 커뮤니티에서 폭넓게 사용중이다단점 이해하기 힘들 수 있다. 보일러플레이트 코드가 너무 많다.Provider장점 플러터 팀이 지원한다 사용자가 많다.단점 아래에 나올 Riverpod에서 해결된 문제가 산재해있다.GetX장점 매우 심플하다. 매우 짧은 코드 높은 사용률 의존성 주입단점 GetX 패키지에 종속된다. 지원이 크지 않다. 너무 많은 문제가 있는 너무 큰 패키지 GetX 패키지 개발이 활발하지 않다. → fix에 너무 많은 시간이 걸린다.States_Rebuilder장점 undo redo 지원 개발이 활발하다단점 상태관리 외의 너무 많은 일을 한다. 지원이 크지 않다. 사용자가 많지 않다.Riverpod 심플하며 Provider와 유사하다.단점 이용자가 많지 않다. 시험단계에서 막 나왔다. 완전히 안정적이지 않다.MobX장점 매우 심플 초심자에게 좋다. 지원을 받고 있다. 보일러 플레이트 코드가 없다.단점 매 업데이트 마다 새로운 코드를 작성해야 한다. MobX 개발자의 활동이 좋지 않다.Redux장점 이미 Redux를 아는 사람에게 좋다.단점 좋은 공식문서가 없다. 플러터 커뮤니티에서 많이 사용하지 않는다.BLoC공유하고자 하는 Data를 전역변수로 선언해서 사용한다.상태 변경class CountBloc { int _count = 0; // 상태 final StreamController&lt;int&gt; _countSubject = StreamController&lt;int&gt;.broadcast(); // Stream 생성 Stream&lt;int&gt; get count =&gt; _countSubject.stream; // 구독자들에게 변경 사항 전송 add() { _count++; _countSubject.sink.add(_count); // 이벤트를 받아 stream에 상태 변경 추가 }}UI 상태 받아 처리하기return Center( child: StreamBuilder( stream: countBloc.count, //&lt;--stream 들 중에서 countBloc.count 값 구독 initialData: 0, builder: (BuildContext context, AsyncSnapshot&lt;int&gt; snapshot) { if (snapshot.hasData) { return Text(snapshot.data.toString()); } return CircularProgressIndicator(); }, ), );ProviderProvider을 선언하면서, Provider에 속한 자녀들은 전부 Provider에 접근이 가능하다.단, 상위 Widget은 하위 위젯의 Provider에 접근이 불가능 하다.MaterialApp( title: 'Flutter Demo', home: MultiProvider( providers: [ ChangeNotifierProvider( create: (BuildContext context) =&gt; CounterProvider()) ], child: Home(), ), );- ChangeNotifier 상속받아 notifyListeners() 상태 변경 사항을 알림.class CounterProvider extends ChangeNotifier { int _count = 0; // 상태 add() { _count++; //상태 변경 notifyListeners(); // 상태 변경 된 것을 알림 }}" }, { "title": "[JAVA] JAVA의 Overloading, Overriding", "url": "/posts/JAVA-Overloading-Overriding/", "categories": "Tech, JAVA", "tags": "JAVA, TIL", "date": "2022-06-20 14:28:50 +0900", "snippet": "오버로딩같은 이름의 함수를 여러개 정의하고, 매개변수와 유형을 다르게 해서 다양한 유형의 호출에 응답할 수 있게 하는 것을 오버로딩이라고 한다.class OverloadingTest{\tvoid cat(){\t\tSystem.out.println(\"매개변수 없음\");\t}\tvoid cat(String sound){\t\tSystem.out.println(sound);\t}\tvoid cat(int number){\t\tsystem.out.println(\"number is \" + number);\t}}public cass OverTest{\tpublic static void main(String[] args){\t\tOverloadingTest testObject = new OverladingTest();\t\ttestObject.cat(); //\"매개변수 없음\"\t\ttestObject.cat(\"Mew\"); //\"Mew\"\t\t\t\ttestObject.cat(3); //\"number is 3\"\t}}오버로딩은 다음과 같이 car()이라는 같은 이름의 메소드에 대해서 다른 파라미터를 받아서 실행되는 형식으로 작동한다.오버로딩에는 메서드 오버로딩과 생성자 오버로딩이 있다.오버라이딩클래스의 변수가 상속되는 것 처럼, 메소드도 상위에서 하위로 갈 수 있다. 또한, 하위클래스에서 메서드를 재정의 해서 사용할 수 있다. 이를 오버라이딩이라고 한다.오버라이딩은 매서드의 이름이 같고, 매개변수도 같고, 반환형도 같을 경우, 상속받은 메서드를 덮어쓰는 방식으로 사용하겠다는 것을 뜻한다.class man{\tpublic String name;\tpublic int age;\tpublic void info(){\t\tSystem.out.println(\"남자의 이름은\" + name\", 나이는 \" + age + \"살입니다.\");\t}}class job extends man(\tString job;\tpublic void info() {\t\tsuper.info();\t\tSystem.out.println(\"여자의 직업은 \" + job + \"입니다.\");\t}}public class OverTest{\tpublic static void main(String[] args){\t\tJob job = new Job();\t\tjob.name = \"인규\";\t\tjob.age = 26;\t\tjob.job = \"프로그래머\";\t\tjob.info(); //남자의 이름은 인규, 나이는 26살입니다.\t\t\t\t\t\t\t\t\t\t//인규의 직업은 프로그래머입니다.\t}}" }, { "title": "[PeachTri] PeachTri 네번째 세미나 - 가비지 컬렉션", "url": "/posts/Peach-Tri-4th-seminar/", "categories": "Blogging, PeachTri, Seminar", "tags": "세미나, PeachTri", "date": "2022-06-14 12:02:00 +0900", "snippet": "가비지 컬렉션 :wastebasket:가비지 컬렉션이란? ❓흔히 Managed 언어와 Unmanaged언어로 언어의 특징을 나눈다. 각각의 언어는 Memory allocation이 언어 자체적으로 지원하는지, 아니면 개발자가 직접 만져줘야 하는지에서 나오는 차이가 있다. 각각의 언어의 특징은 다음과 같다. ### Unmanaged 💻 언어가 따로 메모리 관리를 해주지 않고, 직접 할당과 해제를 해줘야 한다. pros Managed언어에 비해 빠르고, 코딩 자유도가 높다. cons 매번 할당하는게 번거롭고, 메모리 누수 문제가 발생할 수 있다. Managed 👨‍🏭 언어에서 따로 메모리 관리를 해주는 언어를 말한다. pros 자체적으로 관리하기 때문에, 개발하는데 더 편안하다. 이미 해제한 메모리를 또 해제한다던지, 유효하지 않은 포인터에 접근한다던지 하는 문제가 생기지 않는다. cons UnManaged언어에 비해 느리고, 잠재적인 문제에 대비하여서 어느정도 메모리 관리에 대한 지식이 요구된다. 그렇다면 가비지 컬렉션은 무엇일까? 가비지 컬렉션은 Managed언어에서 더 이상 사용하지 않는 변수가 메모리에 저장되어 용량을 차지하는 것을 막기 위해서 사용하지 않는 리소스를 찾아 메모리에서 free()시키는 기능이다.예를 들어, Java의 가비지 컬렉션의 경우, 영역을 두가지로 나눠서 가비지 컬렉션을 한다. 1. Young 영역 새로이 생성된 객체가 할당되는 영역 대부분의 객체가 금방 Unreachable한 상태가 되기 때문에 금방금방 생성되고 사라진다. 2. Old 영역 Young영역에서 Reachable한 상태를 유지하여 살아남은 객체가 복사되는 영역 Young에 비해 영역이 크게 할당되고, 영역의 크기가 커서 가비지도 적게 발생한다. 이런식으로 자바는 두가지로 나눠서 영역에 메모리를 할당한다.그리고 가비지 컬렉션은 Stop The World 어플리케이션의 실행을 멈추고, Mark and Sweep 메모리를 식별해 사용하지 않는 객체들을 메모리에서 제거한다.Flutter의 구조Flutter는 디버그와 배포단에서 다른 컴포넌트를 들고 간다. Debug모드에서는 Runtime과 JIT/Interpreter, 그리고 개발자 서비스 등이 포함되어 있고, 배포단에서는 런타임 컴포넌트만 가져가게 된다. 가비지 컬렉션을 두려워 하지 말아줘!The Dart Garbage Collector다트의 가지비 컬렉터는 두가지 페이즈를 가지게 된다. Scheduling Young Space ScavengerScheduling이 전의 Stop The World에서 알다시피, GC를 진행하기 위해서는 어플리케이션의 중지가 필요하다. GC에서는 플러터 엔진에게 Hook을 제공하는데 이 Hook을 통해서 플러터의 어플리케이션이 구동되다가 유저와의 Interaction이 없는 순간을 알려준다. 퍼포먼스에 크게 영향을 끼치지 않으면서 사용하지 않는 메모리 공간을 확보하기 위해서 존재하는 페이즈이다.Young Space Scavenger플러터 또한 자바의 그것과 비슷한 방식으로 동작한다. stateless widget과 같이 짧은 생명 주기의 객체들을 위해서 고안된 단계이며, Mark and Sweep 보다 빠른 방식으로 동작한다. 플러터가 이러한 방식을 추구하는 이유는 아무래도 어플리케이션의 퍼포먼스 떄문이다.bump pointer allocation다트는 bump pointer allocation이라는 방식을 통해서 메모리를 할당하는데. 먼저 메모리 공간을 두 가지로 나눈다. 하나는 Active Space고 하나는 Inactive space인데, 먼저 오브젝트들을 active 공간에 집어넣고, active space가 전부 차게 되면 그 안에서 오브젝트들이 Dead인지 Live한지 참조하는 다른 오브젝트들을 확인하여서, live하다면 Inactive Space에 옮기고 Dead라면 놔둔다. 그리고 두 공간의 용도를 바꿔주면, live한 오브젝트만 존재하는 메모리는 Active Space가 되고, Dead한 오브젝트들은 Inactive Space에 존재하는게 된다. 이러한 방식으로 메모리 공간과 활성화 비활성화 오브젝트에 대해서 계속해서 관리해나간다.Parallel Marking and Concurrent Sweeping객체가 특정 생명주기에 다다르게 되면(보통은 어느정도 장기화 되었다고 생각되면), 두번째 단계의 GC의 관리하에 들어가게 된다. Mark and Sweep방식인데, 이것은 위의 범프 포인터 방식보다는 좀 느리지만 확실한 방식으로 동작한다. 먼저 오브젝트들을 순회하면서 사용중인지 아닌지, 사용중이라면 표시하고(Mark), 한번 더 메모리 전체를 순회하면서 더 이상 사용하지 않는 오브젝트 공간들을 비운다. 이 때 표시한 마크들도 전부 회수한다.(Sweep) 마킹 단계에서 UI 스레드가 차단되고, 메모리 변화도 차단하기 때문에, Young Scavenger보다는 성능에 영향을 끼치게 된다. 따라서 Mark and Sweep 과정에 있어서 항상, 약한 세대 가설(weak generational hypothesis)를 준수하도록 생각해야한다. 만약 이러한 가설을 생각해놓지 않는다면, 모든 오브젝트들이 장기화를 가정으로 생성이 되고, 그렇다면 GC과정의 대부분이 Mark and Sweep 과정으로 일어나게 되고, 결국 UI스레드나 어플리케이션의 성능에 영향을 끼치게 된다. 약한 세대 가설은 생성된 오브젝트의 대부분이 금방 쓰레기가 되어서 메모리에 공간만 차지하게 된다는 가설이다.IsolatesUsolates는 다트의 코드가 실행되는 공간으로, 싱글 스레드로 동작한다. 다만 기존의 언어들과는 차이점이 존재하는데,자바는 다음과 같이 프로세스내의 스레드간에는 메모리가 공유가 되는 형태이다.하지만, Dart의 isolate는 스레드 자체적으로 메모리를 가지고 있으며, 메모리가 공유되지 않는다는 특징을 가지고 있다. isolate간의 메시지를 주고 받아야 하는 방식을 사용해야하는 불편함은 존재하지만 멀티 스레드를 사용함에 있어서 공유자원에 대한 컨트롤에 신경쓰지 않아도 된다는 장점이 존재한다. 이부분은 차후에 Dart언어에서 비동기를 처리하는 부분에서도 사용이 된다.isolate들은 각자 전용의 heap메모리를 가지고 있고 이러한 구조는 자연스럽게 내부적으로 레이어들이 분리되는 효과를 가지게 된다.참고 문헌https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30플러터 공식 미디엄에 올라온 글" }, { "title": "[PeachTri] PeachTri 두번째 세미나 - 클린코드", "url": "/posts/Peach-Tri-2nd-seminar/", "categories": "Blogging, PeachTri, Seminar", "tags": "세미나, PeachTri", "date": "2022-06-03 11:43:00 +0900", "snippet": "클린코드 🧑‍💻깨끗한 코드란?깨끗한 코드가 무엇이냐는 질문에 내가 생각하는 가장 좋은 대답은, 누구나 이해하기 쉬운 코드라고 생각한다. 읽는 사람이 중학교 수준이더라도, 언어의 이해나 for같은 어법을 전부 덜어내고서라도 흐름을 설명하고 각 메소드나 객체가 어떤 역할인지 말했을 떄 쉽게 이해하는 정말 깨끗한 코드라고 생각한다.깨끗한 코드가 되기 위한 조건 💁 이해하기 쉬운 이름 단순한 함수 명령과 조회의 분리 오류보다는 예외 Test-Driven 단순한 클래스 높은 클래스 응집도, 낮은 결합도 변경하기 쉬운 클래스 디미터 법칙다음과 같은 조건들을 생각하면, 코드를 작성하는데 있어서 초기에는 시간이 더 들지만, 우리가 목표하고자 하는 살아있는 프로그램을 위해서는 초기 투자라고 생각할 수 있다.___이해하기 쉬운 이름우리가 만드는 수많은 클래스, 함수, 변수들의 이름들은 무심하게 짓기 십상이다. 하지만, 이러한 네이밍은 나중에 유지보수에서 엄청나게 애를 먹을 뿐만 아니라. 협업에 있어서 문제를 일으키는 원인이라는 것을 알고 있어야 한다. 의도가 분명한 이름 잘못된 정보가 없는 이름 검색하기 쉬운 단어 상수 사용 클래스 이름은 명사, 메서드 이름은 동사int num = 10;int totalClientNumber = 10;다음과 같은 네이밍은 이 num이라는 변수가 어떤 곳에 쓰이고 어떤식으로 코드내에서 역할을 하는지 이름으로는 알 수 없게 된다. 아래와 같은 경우는 총 클라이언트의 숫자를 뜻하는 변수임을 알 수 있는 상대적으로 직관적인 네이밍이라고 할 수 있다.상수의 사용에 있어서도 비슷하게 적용 가능하다.for (int i = 0; i &lt; 10 ; i++){ //code}만약 다음과 같은 loop가 존재할 때, 10이라는 숫자는 어떤것으로 확정되어 있는지, 왜 10번 돌아야 하는지 알 수 없기 때문에 이런 경우 constant(상수) 를 사용하여서, 값 자체가 이름을 가지도록 하는 것이 좋다.또한 이름에 전체적으로 검색하기 쉽고, 함수에서 동작이 같다면 같은 이름으로 적용해주는게 좋다.int getStudentGrade(){ //code}String takeStudentName(){ //code}두 메서드 전부 학생의 이름 학년을 가져온다고 했을 때, get과 take라는 비슷한 의미의 다른 단어를 사용해서, 코드가 나중에 유지보수될 때 혼란을 초래할 수 있다. 이름이 다르면 의도도 달라야한다___단순한 함수우리는 객체지향에서 SOLID 법칙에 대해서 들어봤다. 여기서 첫번째로 나오는 Single Resposibility Principle은 작성된 클래스가 하나의 기능을 가지고 있어야 한다는 원칙인데, 이와 유사하게, 함수또한 하나의 함수에 하나의 기능이 존재해야한다. 함수는 하나의 기능만 존재 최대한 작게 만들기 함수 인수 최대한 적게 작게 만들기void infoStudent(case){ switch(case){ case 'name' print(this.name); case 'grade' print(this.grade); case 'score' print(this.score); }}만약에 위와 같은 infoStudent 메서드를 만들었다고 가정할 경우. SRP를 위반하고, OCP또한 위반하여서 만약에 학생 정보가 업데이트 된다면, infoStudent라는 메서드까지 전부 변경해야하게 됩니다.명령과 조회의 분리흔히 데이터를 조회하고 데이터를 modify하는 과정은 앱에 있어서 자주 일어나는 일이다. 이 때, 함수가 명령, 조회를 전부 처리한다면 함수를 유지 보수 하는 과정에서 이해하기 어려운 코드가 될 확률이 높아진다.bool set(String attribute, int value);if(set(\"영찬\", 2)){ //code}다음과 같은 예시에서, set이라는 메서드는 “영찬”이 존재하는지, 존재한다면 overwirte하는지, 아니면 새로 작성하는지 알 수 없다. 또한 그 결과를 bool타입으로 반환까지하는 아주 복합적인 함수다.isAttributeExist()setAttribute()다음과 같이 조회와 명령을 분리하여서, 값이 존재하는지에 대해, 그리고 그 값을 설정하는 두 가지로 나눠서 정의하면 좀 더 유지보수도 편하고 human-readable한 함수가된다.___오류보다는 예외Status deletePage(Page page) { if(deletePage(page) == E_OK) { if(registry.deleteReference(page.name) == E_OK) { if(configKeys.deleteKey(page.name.makeKey()) == E_OK) { log.info(\"page deleted\"); return E_OK; } else { log.error(\"config key not deleted\"); } } else { log.error(\"reference not deleted\"); } } else { log.error(\"page not deleted\"); } return E_ERROR;}다음과 같이 페이지 삭제 메소드에서 각각의 분기에서 에러를 출력한다고 한다면, 코드도 너무 길고, 구조적으로 가장 좋지않은 if-else문의 남발로 읽기 힘든 코드가 된다.void deletePage(Page page) { try { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } catch (Exception e) { log.error(e.getMessage()); }}다음과 같이 try-catch로 묶어준다면, 훨씬 가독성이 좋은 코드가 완성된다.___Test-Driven-Development테스트 코드는 우리가 작성할 메인 코드 만큼이나 중요하다. TDD는 우리가 실제 코드를 짜기 전부터 단위 테스트를 먼저 작성하는 기법이다. 테스트 코드를 먼저 작성해보는 것은, 코드의 전체적인 로직을 파악하고 구성하는데 있어서 유연함을 제공한다. 실패하는 단위테스트를 작성하기 전 까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서, 실행이 실패하는 정도의 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.또한 SRP처럼, 1개의 테스트 코드는 1가지 개념만을 테스트하는 것이 바람직하다.또한 깨끗한 테스트 코드를 위한 FISRT규칙도 존재한다. Fast 빠르게 Independent 독립적으로 Repeatable 재사용 가능하게 Self-Validation 자체 검증 Timely 적시에___ 단순한 클래스 클래스 또한 함수와 마찬가지로 최대한 간결하게 작성하는 것이 좋다. SRP에 따라서 1가지 책임만 가져야 한다.___ 높은 클래스 응집도, 낮은 결합도 응집도는 클래스의 메소드와 변수가 클래스에 얼마나 의존되는지 이고, 결합도가 높으면 다른 클래스간의 요소들이 얼마나 의존하고 있는지이다.응집도는 높혀야 하고, 결합도는 낮아야 한다. 응집도가 너무 낮은 클래스는 다른 클래스의 변화에 민감해지고, 유지보수하기 힘들며, 재사용과 유지보수가 힘들다.___ 변경하기 쉬운 클래스 코드를 작성하면, 요구사항이 계속해서 변하기 때문에, 클래스도 변경하기 쉬워야 한다. SRP는 이를 위해서 기본적으로 지켜져야할 원칙이며, 추상체를 통한 다형성을 통해 클래스가 변경하기 쉬워져야 한다. OCP를 통해서 기존의 코드가 확장되어 변경하는건 쉽지만, 이미 작성되어 있는 코드가 변경되는 일은 적어야 한다___ 디미터 법칙 객체지향에서 중요한 법칙으로, 객체내의 자료를 공개하는 것이 아니라, 함수를 공개하는 법칙을 말한다. 객체가 어떤 메세지를 주고 받는가? class User { String _email; String _name; Address _address;}class Address { String _region; String _details;}다음과 같은 코드가 있다고 했을 때.class NotificationService { void sendMessageForSeoulUser(User user) { if(\"서울\".equals(user.getAddress().getRegion())) { sendNotification(user); } }}다음과 같이 코드를 짜게 되면 , class 객체가 가지고 있는 region을 확인한다.class Address { String region; String details; bool isSeoulRegion() { return \"서울\".equals(region); }}class User { String email; String name; Address address; bool isSeoulUser() { return address.isSeoulRegion(); }}이런식으로 메세지를 구현하면, 내부 데이터를 모르는 채 메세지를 보낼 수 있게 된다.class NotificationService { void sendMessageForSeoulUser(User user) { if(user.isSeoulUser()) { sendNotification(user); } }}" }, { "title": "[PeachTri] 첫번째 세미나", "url": "/posts/Peach-Tri-1st-seminar/", "categories": "Blogging, PeachTri, Seminar", "tags": "세미나, PeachTri", "date": "2022-05-27 20:00:00 +0900", "snippet": "" }, { "title": "[BLOG] 대학교 졸업 작품을 끝마치며...", "url": "/posts/%EB%8C%80%ED%95%99%EA%B5%90-%EC%A1%B8%EC%97%85%EC%9E%91%ED%92%88%EC%9D%84-%EB%81%9D%EB%A7%88%EC%B9%98%EB%A9%B0/", "categories": "Blogging, Chat", "tags": "회고, 대학교, 게임", "date": "2022-05-24 17:37:00 +0900", "snippet": "길었던 졸업작품을 마치고…드디어 작년 2학기부터 시작되었던 졸업작품 제작이 전부 끝나게 되었다.나는 스릴러러버 팀에서 AI와 PostProcessing을 담당하였다. AI는 3학년 2학기와 4학년 1학기에 거진 다 마무리를 짓게 되었고, 4학년 1학기에 와서 포스트 프로세싱을 담당하게 되었다.사실 웹개발을 선호하는 나로써는 조금 아쉬운 작품이었고, 조금 아쉬운 주제였다(그 아쉬움은 현재 Peach-Tri팀을 통해서 해소하고 있다..)여튼, 이러한 프로젝트 주제를 설정하게 된 이유는 크게 두가지 이다. 엔터테인먼트 소프트웨어 수업 내용을 그대로 활용할 수 있다. 완전히 다른 분야인 게임 개발을 찍먹해볼 수 있다.사실 나중에 포트폴리오 용으로도 제출하거나 했을 때 너무 얕아서 힘들지 않을까 하는 생각이 들었다. 하지만, 게임 개발도 어떻게 보면 개발이고, 혼자서라도 해보지 않은 분야이며, 나머지 조원들이 정말 많은 관심이 있었기 때문에 선정하였고, 이건 개발 외 적이지만, 영상편집(특히나 3D)를 경험해본 나도, 이미 알고 있는 부분과 툴을 활용할 수 있을거라는 점에서 흥미를 가지고 접근했다.협업 적응기협업은 생각보다 적응하기 어려웠다. 각자 일하는 스타일이 있고, 노드를 연결하는 스타일이 있고, 변수명을 저장하는 스타일이 있었다. 코딩 컨벤션과 같이 이름을 짓거나, 노드를 연결할때 서로의 약속이 있었지만, 아무래도 일정이 급박해지면서 그런 부분들이 약간 무시되는 느낌이 없잖아 있었다. 이게 제대로 터진게 바로 Perforce의 사용이었다.Perforce는 버전관리 툴이다. Git을 생각하면 되는데, 퍼포스는 체크아웃과 제출을 바탕으로 좀 더 파일들의 권한에 대해서 강하게 관리하고, 코드가 아닌 큰 용량의 파일들도 잘 관리해준다. 또한 언리얼에서 강력하게 밀고있는 버전관리 툴이기도 해서 한번 사용을 해 봤다. 개인적으로 결과는 대성공이라고 생각된다. 버전관리에 있어서도 체크아웃을 바탕으로 우리끼리 서로 꼬이지 않았고, AWS 서버를 대여하여서 했는데, 파일 누락문제도 단한번 일어나지 않았었다. 물론 Git으로 먼저 작업한 적은 없지만, 불편함이 없으면 좋은거라는 생각이다. 원래 서버 같은 장비도 문제가 없어서 못느끼지, 실제로는 전문가들이 엄청나게 열심히 관리중이라는 뜻이니까!! 어마어마한 용량의 게임(20GB정도)를 AWS에서 유지하느라 유지비가 꽤나 들어갔지만…. 그럼에도 새로운 경험이라고 생각해서 기분은 좋았다. 중간에 버전업에 문제가 생기거나, 완전히 필요없는 찌꺼기 파일들을 털어낸다고 서버를 싹 지우고 다시 올린 적이 있었는데, Putty나 AWS 콘솔을 통하여 업로드 하고 status를 관리하는 경험도 즐거웠다.언리얼 적응기사실 언리얼에는 적응이라고 할게 있었는지 모르겠다. 열심히 코드를 적는 경험만 했었던 것도 아니고, 나는 후디니나, 다른 툴들을 한번씩 써보면서 노드 연결에는 익숙해져 있었다. 사실 노드를 쭉 쓰면서 느끼는 점은, 조금만 길어지면 한눈에 알아보기 힘들다는 점이 있다. 디자이너들에게는 정말 친근하고 편한 접근방식일 수 있지만, 노드를 잘 보이도록 배열하기 위해서는 생각보다 에너지가 많이 든다. 깨끗하게 작성된 코드를 만드는 것도 에너지가 많이 소모 되지만 말이다. 하여튼! 노드는 장단이 좀 있다~해본 후기협업은 상당히 에너지가 소모 되지만, 그 만큼 높은 수준의 작품이 나온다는건 부정할 수 없는 사실이다.발표영상을 보고 싶다면 아래의 유튜브 영상을 참고하길 바란다. 우리팀이 아무래도 아트적인 관점에서 작업한 부분이 많아서 기술적인 부분이 조금은 부족해 보일지 모르지만, 게임은 종합 예술인 만큼, 기술적인 부분만 집중되어야 한다도 어불성설같다." }, { "title": "[BLOG] Github 블로그 수정기", "url": "/posts/Github-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%88%98%EC%A0%95%EA%B8%B0/", "categories": "Blogging, Chat", "tags": "Github, Blog, Chat", "date": "2022-05-06 19:40:00 +0900", "snippet": "깃허브 블로그 생성일기왜 깃허브 블로그?사실 벨로그를 진작에 시작하기도 했고, 내가 좋아하는 테크 블로그들은 미디엄에 많이 분포한 상황이었다. 그래서 나도 벨로그와 미디엄 사이에서 많이 갈등 했었고 어떤걸 가지고 블로그를 시작할지 정말 많이 고민을 했고 끝내 결론을 내린것이 깃허브 블로그였다. 다양한 관점에서 블로그에 쓸모를 생각해 본 결과, 나의 결론은 ‘포트폴리오이자, 개발자로써 나의 테크 일기’의 느낌이었다. 내가 프로젝트나 다양한 작업을 하면서 있었던 이슈, 원인, 결과를 분석하고 기록해 놓으려고 많들어 놓은 블로그이며, 이것은 내가 나중에 프로젝트에 대해서 돌이켜 보거나, 누군가 내가 어떤 사람인지를 궁금해 할 때 보여줄 수 있는 자료로 굉장히 유용하다고 생각했다. 그런 의미에서 블로그를 시작했고, 이제는 어떤 사이트를 써야하는지에 대해서 갈등했다. 그 결과 세가지로 좁혀졌다.편안함의 벨로그 벨로그는 편안하다. 한국에서 서비스 되며, 광고도 따로 없고, 글들도 주니어 개발자나 취준생등등 나와 비슷한 사람들이 많아서 정보를 얻기 쉽다는 점이 매력적이다. 또한 마크다운을 통해서 글을 쓰기 때문에 글을 작성하기도 편하고, 작성된 글 들도 편안하게 읽힌다는 장점이 있다. 단점은 올라오는 글들이 대부분 특정 회사의 인턴십에 관한 이야기 이며, CS적으로 단순한 내용이 비교적 많고, 글을 기록할 때 너무 단순하다 보니 보람(?)이 느껴지지 않는다는 점이었다. 편리함을 큰 장점으로 두고 다음으로 넘어갔다.컨텐츠의 미디엄 미디엄은 상대적으로 컨텐츠가 풍부하다. 글을 올리는 사람들도 현업 시니어 엔지니어들이 많아서 글들이 영양가가 높다. 또한 영문으로 작성된 글들도 상당하기 때문에 양질의 정보를 정말 많이 얻을 수 있다. 단점으로 이건 구독형의 유료 계정이 옵션으로 존재하며(이건 독자 한정으로 아쉬운 느낌, 이해는 하지만 약간 비싸게 느껴지기도 한다.) 한글 폰트가 좀 아쉽고, 마크다운이 아니라서 글을 쓰기 좀 힘들다는 점이 따라온다.커스터마이징, 테크함의 깃허브 블로그 깃허브 블로그는 오히려 매우 불편하다. 자바스크립트, html, css를 이해해야 그럴듯한 생성이 가능하며, 지킬을 통해서 프리셋 테마들을 사용할 수 있지만, 완전히 똑같은건 또 싫다. 결국 커스터마이징을 해야하는데, 옵션이 폭넓다는 점이 매력적이지만 그 만큼 매력을 전부 사용하려면 노동을 해야하는 단점이 존재한다. 하지만 깃 허브 블로그의 커스터마이징과, ‘테크’함이 포트폴리오도로 참 좋고, 내가 직접 운영한다는 느낌이 좋아서 열심히 이리저리 강좌 찾고 구글링 하면서 현재 커스터마이징 하게 되었다.마무리아직도 깃허브 블로그에 익숙해졌다는 느낌은 안든다. 아직은 선택권도 좀 넓어졌다는 느낌, 벨로그와 깃허브를 살짝씩 써 봤는데, 내 느낌에는 깃허브가 좀 더 유의미한 느낌이 많이 든다. 미디엄이 어떨지 모르겠지만, 읽기는 참 좋은데 전문가들이 많아서 쓰기에는 좀 무섭다는 느낌도 없지 않아서 있다. 일단은 블로그를 어떤걸 쓸까 보다는 어떤 글을 어떤식으로 기록할까에 좀 더 촛점을 맞추면서 블로깅을 하고 싶다. 다음에는 깃허브 블로그를 셋팅하면서 있었던 이슈와 해결법에 대해서 메모하려고 한다. M1 맥이다 보니 여러 일화들이 많은데, 찬찬히 풀어나가려고 한다." }, { "title": "[PeachTri] Team PeachTri 출범!", "url": "/posts/Team-PeachTri-started/", "categories": "Blogging, PeachTri", "tags": "Begin, Blog, Chat, PeachTri", "date": "2022-05-06 18:57:00 +0900", "snippet": "Team Peachi-Tri나의 첫번째 Toy Project 팀4학년 2학기에 접어 들어서, 뚜렷하게 프로젝트를 진행한 경험이 많이 부족하다는 생각이 들었다. Unreal을 통해서 게임 프로젝트는 진행 했었지만, 정작 내가 하고 싶었던, 웹앱이나 어플리케이션에 대한 프로젝트가 전혀 아니었기 때문에, 진행함에 있어서 의욕이 마구 샘솟는 느낌은 아니었다. 그래서 대학 동기와 친구랑 같이 셋이서, 자그마한 토이 프로젝트 팀을 결성했다. 한명은 현직, 한명은 졸업반, 한명은 이제 신입생이다. 셋 전부 관심이야 많고 학과도 같아서 한명은 자신의 이직 포폴, 한명은 자신의 취업 포폴, 한명은 스터디 이런식으로 나뉘어서 열심히 개발해 볼 생각이다.왜 Flutter와 Firebase 였는가?간단히 말해서 간편함이었다. 우리의 가장 첫번째 목표는, 익히기 쉽고, 구현하기 쉬운 툴들을 사용하여서 가장 최소한의 서비스로 시작하는 것이다. 일단 만들어진 앱에 대해서 추가 구현과 개발을 경험해보자는 생각이었다. 너무 기획단에서 커져버리면, 진이 빠지고, 프로젝트가 중도에 퍼져버린다. 우리는 Flutter를 건드려본겅험이 아니라 개발하고, 배포해본 경험을 하고 싶었다.서비스 개발을 경험하고 싶다.앞으로의 나의 진로, 미래가 어떤식으로 흘러갈지 모르겠다. 하지만 한가지 희망 사항은, 서비스를 하나 개발해 계속해서 유지보수하고 관리하는 경험을 해 보고 싶다. 누군가 쓰고 있는 어플리케이션이 내가 처음부터 뛰어들어 개발하여, 쭉 유지하고 지금까지 관리하고 있다는 경험이 굉장히 짜릿하게 느껴진다.나는 개발 관심사가 참 많았다. 아직 경험하지 않아서 관심만 많은 상태를 빨리 벗어나고 싶다. 이런 저런 찔러보기는 그만하고, 도서관, 유튜브를 찾아가면서 열심히 공부해볼 생각이다." }, { "title": "꿈꾸는 개발자 장인규 입니다.", "url": "/posts/%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%A9%EB%8B%88%EB%8B%A4/", "categories": "Blogging, Greetings", "tags": "세미나, PeachTri", "date": "2022-05-04 23:32:20 +0900", "snippet": "안녕하세요. 꿈꾸는 개발자 장인규라고 합니다.저의 블로그에 오신것을 환영합니다.이 블로그는 제가 공부한 내용, 해결한 이슈, 기타 CS관련 지식과 정보, 그리고 잡담등을 기록하기 위한 블로그 입니다.Velog와 함께 병행하고 있으며, 차후 velog의 모든 내용을 마이그레이션 할 계획입니다.아무래도 블로그 글 작성에 있어서 velog가 간편한 점이 많아서 먼저 작성 후, 깃허브 블로그에도 업로드 합니다." }, { "title": "[NodeJS] NodeJS는 어떻게 동작할까? - 작성중", "url": "/posts/how-nodejs-works/", "categories": "ProgrammingLanguage, NodeJS", "tags": "JavaScript, ProgrammingLanguage, NodeJS", "date": "2022-03-30 11:42:00 +0900", "snippet": "📌 NodeJS는 어떻게 돌아가는 걸까?최근 NestJS를 공부해보고 싶어서, 자바스크립트를 한번 다시 돌이켜보고, 타입스크립트도 공부해보려는 요량으로 있었다. 스프링과 상당히 유사하게 돌아가는(것 처럼 보이는) 프레임워크로 꼽히는 NestJS가 과연 어떤식으로 돌아갈까 보려고 하다가 결국 NodeJS가 어떤식으로 돌아가는지 찾아보고 (사실상 JVM공부 마냥 들어가는 느낌이다.) 정리하려고 이 포스트를 작성한다. 해당포스트는 여러 정보를 기반으로 작성하며, 앞으로 계속해서 수정하려고 한다.Java + Spring 스택의 코드 예시이다.package com.example.springboot;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController {\t@GetMapping(\"/\")\tpublic String index() {\t\treturn \"Greetings from Spring Boot!\";\t}}그리고 NestJS 스택의 코드 예시이다.import { Controller, Get } from '@nestjs/common';@Controller('cats')export class CatsController { @Get() findAll(): string { return 'This action returns all cats'; }}컨트롤러 샘플만 보면 정말 비슷한 것 같다.NestJS를 써본 분들이라면, 저런 컨트롤러쪽에 provider같은게 더 추가되어야 한다는 점을 알겠지만 일단은 생략한다. 와 뭐야 스프링이네근데 문제는 이녀석들의 언어가 문제이다. JS(TS)와 JAVA 더 나아가서 Node와 JVM의 차이는 생각보다 크고, 이 다른점들이 각각의 프레임워크에도 어느정도 녹아있는 느낌이다.📎 그럼 노드는 어떤게 다른걸까?Spring이라는 프레임워크는 JVM이라는 가상머신에서 돌아가는 JAVA라는 언어에 뿌리를 두고 있다. 동기적, 멀티스레드의 성향이 나타나고, 최근에는 WebFlux를 통해서 비동기 처리에도 박차를 가하고 있다. 전체적으로 웹개발을 위해 필요한 모든 기능이 전부 들어가 있는 패키지에 가깝다. Security와 같은 보안까지 빠짐없이 전부 챙겨주는 든든한 구성이며, 엔터프라이즈급 프로젝트나, 보안이 정말 중요한 프로젝트에서는 이런 구성이 엄청나게 큰 도움이 된다.NodeJS는 \"싱글스레드, 이벤트기반, 비동기\"를 바탕으로 두고 있다. 태생이 스크립트 언어이며, 브라우저 V8엔진을 통해 돌아가도록 디자인된 자바스크립틀 바탕으로 두고 있기 때문에, 노드도 이러한 JS의 기반을 무시할 수 없었을 것이다. 그래서 Nest의 코드 이곳 저곳에도 이러한 특징이 묻어나게 된다.자바스크립트라는 언어의 구동방식 특징이 바로 브라우저상에서 돌아가는 언어라는 점이다. 다른 컴퓨터의 많은 리소스들을 활용할 수 있었던 다른 언어들과는 다르게, 자바스크립트 언어자체가 싱글 스레드로 돌아가고, 중간의 이벤트들은 API로 보내놓고 이벤트 루프를 통해서 다시 받아오는 방식의 비동기 처리를 통해 진행되었다. 이런 웹 브라우저의 환경 (V8엔진이 동작하는 환경)이 아닌, 컴퓨터의 리소스와 직접적으로 맞닿아 있는 NodeJS는 과연 어떤식으로 동작할까?여기서 핵심적으로 이용되는 라이브러리가 바로 libuv이다.🤦 Trouble Shooting" } ]
